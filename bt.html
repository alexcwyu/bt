
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>bt Package &#8212; bt 0.2.10 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/css/klink.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="Examples" href="examples.html" />
         
        <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9">
        
        <link href='http://fonts.googleapis.com/css?family=Open+Sans:300,400,700' rel='stylesheet' type='text/css'>
        <link href='http://fonts.googleapis.com/css?family=Droid+Sans+Mono:400,500,700' rel='stylesheet' type='text/css'>
    
  </head><body>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="bt-package">
<h1>bt Package<a class="headerlink" href="#bt-package" title="Permalink to this heading">¶</a></h1>
<div class="section" id="id1">
<h2><code class="xref py py-mod docutils literal notranslate"><span class="pre">bt</span></code> Package<a class="headerlink" href="#id1" title="Permalink to this heading">¶</a></h2>
<span class="target" id="module-bt.__init__"></span></div>
<div class="section" id="module-bt.algos">
<span id="algos-module"></span><h2><code class="xref py py-mod docutils literal notranslate"><span class="pre">algos</span></code> Module<a class="headerlink" href="#module-bt.algos" title="Permalink to this heading">¶</a></h2>
<p>A collection of Algos used to create Strategy logic.</p>
<dl class="py class">
<dt class="sig sig-object py" id="bt.algos.CapitalFlow">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">bt.algos.</span></span><span class="sig-name descname"><span class="pre">CapitalFlow</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">amount</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/algos.html#CapitalFlow"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.algos.CapitalFlow" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#bt.core.Algo" title="bt.core.Algo"><code class="xref py py-class docutils literal notranslate"><span class="pre">Algo</span></code></a></p>
<p>Used to model capital flows. Flows can either be inflows or outflows.</p>
<p>This Algo can be used to model capital flows. For example, a pension
fund might have inflows every month or year due to contributions. This
Algo will affect the capital of the target node without affecting returns
for the node.</p>
<p>Since this is modeled as an adjustment, the capital will remain in the
strategy until a re-allocation/rebalancement is made.</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>amount (float): Amount of adjustment</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="bt.algos.CloseDead">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">bt.algos.</span></span><span class="sig-name descname"><span class="pre">CloseDead</span></span><a class="reference internal" href="_modules/bt/algos.html#CloseDead"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.algos.CloseDead" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#bt.core.Algo" title="bt.core.Algo"><code class="xref py py-class docutils literal notranslate"><span class="pre">Algo</span></code></a></p>
<p>Closes all positions for which prices are equal to zero (we assume
that these stocks are dead) and removes them from temp[‘weights’] if
they enter it by any chance.
To be called before Rebalance().</p>
<p>In a normal workflow it is not needed, as those securities will not
be selected by SelectAll(include_no_data=False) or similar method, and
Rebalance() closes positions that are not in temp[‘weights’] anyway.
However in case when for some reasons include_no_data=False could not
be used or some modified weighting method is used, CloseDead() will
allow to avoid errors.</p>
<dl class="simple">
<dt>Requires:</dt><dd><ul class="simple">
<li><p>weights</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="bt.algos.ClosePositionsAfterDates">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">bt.algos.</span></span><span class="sig-name descname"><span class="pre">ClosePositionsAfterDates</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">close_dates</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/algos.html#ClosePositionsAfterDates"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.algos.ClosePositionsAfterDates" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#bt.core.Algo" title="bt.core.Algo"><code class="xref py py-class docutils literal notranslate"><span class="pre">Algo</span></code></a></p>
<p>Close positions on securities after a given date.
This can be used to make sure positions on matured/redeemed securities are
closed. It can also be used as part of a strategy to, i.e. make sure
the strategy doesn’t hold any securities with time to maturity less than a year</p>
<p>Note that if placed after a RunPeriod algo in the stack, that the actual
closing of positions will occur after the provided date. For this to work,
the “price” of the security (even if matured) must exist up until that date.
Alternatively, run this with the &#64;run_always decorator to close the positions
immediately.</p>
<p>Also note that this algo does not operate using temp[‘weights’] and Rebalance.
This is so that hedges (which are excluded from that workflow) will also be
closed as necessary.</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>close_dates (str): the name of a dataframe indexed by security name, with columns
“date”: the date after which we want to close the position ASAP</p></li>
</ul>
</dd>
<dt>Sets:</dt><dd><ul class="simple">
<li><p>target.perm[‘closed’] : to keep track of which securities have already closed</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="bt.algos.Debug">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">bt.algos.</span></span><span class="sig-name descname"><span class="pre">Debug</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/algos.html#Debug"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.algos.Debug" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#bt.core.Algo" title="bt.core.Algo"><code class="xref py py-class docutils literal notranslate"><span class="pre">Algo</span></code></a></p>
<p>Utility Algo that calls pdb.set_trace when triggered.</p>
<p>In the debug session, ‘target’ is available and can be examined through the
StrategyBase interface.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="bt.algos.HedgeRisks">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">bt.algos.</span></span><span class="sig-name descname"><span class="pre">HedgeRisks</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">measures</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pseudo</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strategy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">throw_nan</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/algos.html#HedgeRisks"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.algos.HedgeRisks" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#bt.core.Algo" title="bt.core.Algo"><code class="xref py py-class docutils literal notranslate"><span class="pre">Algo</span></code></a></p>
<p>Hedges risk measures with selected instruments.</p>
<p>Make sure that the UpdateRisk algo has been called beforehand.</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>measures (list): the names of the risk measures to hedge</p></li>
<li><p>pseudo (bool): whether to use the pseudo-inverse to compute
the inverse Jacobian. If False, will fail if the number
of selected instruments is not equal to the number of
measures, or if the Jacobian is singular</p></li>
<li><p>strategy (StrategyBase): If provided, will hedge the risk
from this strategy in addition to the risk from target.
This is to allow separate tracking of hedged and unhedged
performance. Note that risk_strategy must occur earlier than
‘target’ in a depth-first traversal of the children of the root,
otherwise hedging will occur before positions of risk_strategy are
updated.</p></li>
<li><p>throw_nan (bool): Whether to throw on nan hedge notionals, rather
than simply not hedging.</p></li>
</ul>
</dd>
<dt>Requires:</dt><dd><ul class="simple">
<li><p>selected</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="bt.algos.LimitDeltas">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">bt.algos.</span></span><span class="sig-name descname"><span class="pre">LimitDeltas</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">limit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/algos.html#LimitDeltas"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.algos.LimitDeltas" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#bt.core.Algo" title="bt.core.Algo"><code class="xref py py-class docutils literal notranslate"><span class="pre">Algo</span></code></a></p>
<p>Modifies temp[‘weights’] based on weight delta limits.</p>
<p>Basically, this can be used if we want to restrict how much a security’s
target weight can change from day to day. Useful when we want to be more
conservative about how much we could actually trade on a given day without
affecting the market.</p>
<p>For example, if we have a strategy that is currently long 100% one
security, and the weighing Algo sets the new weight to 0%, but we
use this Algo with a limit of 0.1, the new target weight will
be 90% instead of 0%.</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>limit (float, dict): Weight delta limit. If float, this will be a
global limit for all securities. If dict, you may specify by-ticker
limit.</p></li>
</ul>
</dd>
<dt>Sets:</dt><dd><ul class="simple">
<li><p>weights</p></li>
</ul>
</dd>
<dt>Requires:</dt><dd><ul class="simple">
<li><p>weights</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="bt.algos.LimitWeights">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">bt.algos.</span></span><span class="sig-name descname"><span class="pre">LimitWeights</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">limit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/algos.html#LimitWeights"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.algos.LimitWeights" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#bt.core.Algo" title="bt.core.Algo"><code class="xref py py-class docutils literal notranslate"><span class="pre">Algo</span></code></a></p>
<p>Modifies temp[‘weights’] based on weight limits.</p>
<p>This is an Algo wrapper around ffn’s limit_weights. The purpose of this
Algo is to limit the weight of any one specifc asset. For example, some
Algos will set some rather extreme weights that may not be acceptable.
Therefore, we can use this Algo to limit the extreme weights. The excess
weight is then redistributed to the other assets, proportionally to
their current weights.</p>
<p>See ffn’s limit_weights for more information.</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>limit (float): Weight limit.</p></li>
</ul>
</dd>
<dt>Sets:</dt><dd><ul class="simple">
<li><p>weights</p></li>
</ul>
</dd>
<dt>Requires:</dt><dd><ul class="simple">
<li><p>weights</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="bt.algos.Not">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">bt.algos.</span></span><span class="sig-name descname"><span class="pre">Not</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">algo</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/algos.html#Not"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.algos.Not" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#bt.core.Algo" title="bt.core.Algo"><code class="xref py py-class docutils literal notranslate"><span class="pre">Algo</span></code></a></p>
<p>Flow control Algo</p>
<p>It is usful for “inverting” other flow control algos,
For example Not( RunAfterDate(…) ), Not( RunAfterDays(…) ), etc</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>list_of_algos (Algo): The algo to run and invert the return value of</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="bt.algos.Or">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">bt.algos.</span></span><span class="sig-name descname"><span class="pre">Or</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">list_of_algos</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/algos.html#Or"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.algos.Or" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#bt.core.Algo" title="bt.core.Algo"><code class="xref py py-class docutils literal notranslate"><span class="pre">Algo</span></code></a></p>
<p>Flow control Algo</p>
<p>It useful for combining multiple signals into one signal.
For example, we might want two different rebalance signals to work together:</p>
<blockquote>
<div><p>runOnDateAlgo = bt.algos.RunOnDate(pdf.index[0]) # where pdf.index[0] is the first date in our time series
runMonthlyAlgo = bt.algos.RunMonthly()
orAlgo = Or([runMonthlyAlgo,runOnDateAlgo])</p>
</div></blockquote>
<p>orAlgo will return True if it is the first date or if it is 1st of the month</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>list_of_algos: Iterable list of algos.
Runs each algo and
returns true if any algo returns true.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="bt.algos.PTE_Rebalance">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">bt.algos.</span></span><span class="sig-name descname"><span class="pre">PTE_Rebalance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">PTE_volatility_cap</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_weights</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lookback=&lt;DateOffset:</span> <span class="pre">months=3&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lag=&lt;DateOffset:</span> <span class="pre">days=0&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">covar_method='standard'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">annualization_factor=252</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/algos.html#PTE_Rebalance"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.algos.PTE_Rebalance" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#bt.core.Algo" title="bt.core.Algo"><code class="xref py py-class docutils literal notranslate"><span class="pre">Algo</span></code></a></p>
<p>Triggers a rebalance when PTE from static weights is past a level.</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>PTE_volatility_cap: annualized volatility to target</p></li>
<li><p>target_weights: dataframe of weights that needs to have the same index as the price dataframe</p></li>
<li><p>lookback (DateOffset): lookback period for estimating volatility</p></li>
<li><p>lag (DateOffset): amount of time to wait to calculate the covariance</p></li>
<li><p>covar_method: method of calculating volatility</p></li>
<li><p>annualization_factor: number of periods to annualize by.
It is assumed that target volatility is already annualized by this factor.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="bt.algos.PrintDate">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">bt.algos.</span></span><span class="sig-name descname"><span class="pre">PrintDate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/algos.html#PrintDate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.algos.PrintDate" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#bt.core.Algo" title="bt.core.Algo"><code class="xref py py-class docutils literal notranslate"><span class="pre">Algo</span></code></a></p>
<p>This Algo simply print’s the current date.</p>
<p>Can be useful for debugging purposes.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="bt.algos.PrintInfo">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">bt.algos.</span></span><span class="sig-name descname"><span class="pre">PrintInfo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fmt_string</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'{name}</span> <span class="pre">{now}'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/algos.html#PrintInfo"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.algos.PrintInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#bt.core.Algo" title="bt.core.Algo"><code class="xref py py-class docutils literal notranslate"><span class="pre">Algo</span></code></a></p>
<p>Prints out info associated with the target strategy. Useful for debugging
purposes.</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>fmt_string (str): A string that will later be formatted with the
target object’s __dict__ attribute. Therefore, you should provide
what you want to examine within curly braces ( { } )</p></li>
</ul>
</dd>
<dt>Ex:</dt><dd><p>PrintInfo(‘Strategy {name} : {now}’)</p>
</dd>
</dl>
<p>This will print out the name and the date (now) on each call.
Basically, you provide a string that will be formatted with target.__dict__</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="bt.algos.PrintRisk">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">bt.algos.</span></span><span class="sig-name descname"><span class="pre">PrintRisk</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fmt_string</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/algos.html#PrintRisk"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.algos.PrintRisk" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#bt.core.Algo" title="bt.core.Algo"><code class="xref py py-class docutils literal notranslate"><span class="pre">Algo</span></code></a></p>
<p>This Algo prints the risk data.</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>fmt_string (str): A string that will later be formatted with the
target object’s risk attributes. Therefore, you should provide
what you want to examine within curly braces ( { } )
If not provided, will print the entire dictionary with no formatting.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="bt.algos.PrintTempData">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">bt.algos.</span></span><span class="sig-name descname"><span class="pre">PrintTempData</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fmt_string</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/algos.html#PrintTempData"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.algos.PrintTempData" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#bt.core.Algo" title="bt.core.Algo"><code class="xref py py-class docutils literal notranslate"><span class="pre">Algo</span></code></a></p>
<p>This Algo prints the temp data.</p>
<p>Useful for debugging.</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>fmt_string (str): A string that will later be formatted with the
target’s temp dict. Therefore, you should provide
what you want to examine within curly braces ( { } )</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="bt.algos.Rebalance">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">bt.algos.</span></span><span class="sig-name descname"><span class="pre">Rebalance</span></span><a class="reference internal" href="_modules/bt/algos.html#Rebalance"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.algos.Rebalance" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#bt.core.Algo" title="bt.core.Algo"><code class="xref py py-class docutils literal notranslate"><span class="pre">Algo</span></code></a></p>
<p>Rebalances capital based on temp[‘weights’]</p>
<p>Rebalances capital based on temp[‘weights’]. Also closes
positions if open but not in target_weights. This is typically
the last Algo called once the target weights have been set.</p>
<dl class="simple">
<dt>Requires:</dt><dd><ul class="simple">
<li><p>weights</p></li>
<li><p>cash (optional): You can set a ‘cash’ value on temp. This should be a
number between 0-1 and determines the amount of cash to set aside.
For example, if cash=0.3, the strategy will allocate 70% of its
value to the provided weights, and the remaining 30% will be kept
in cash. If this value is not provided (default), the full value
of the strategy is allocated to securities.</p></li>
<li><p>notional_value (optional): Required only for fixed_income targets. This is the base
balue of total notional that will apply to the weights.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="bt.algos.RebalanceOverTime">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">bt.algos.</span></span><span class="sig-name descname"><span class="pre">RebalanceOverTime</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/algos.html#RebalanceOverTime"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.algos.RebalanceOverTime" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#bt.core.Algo" title="bt.core.Algo"><code class="xref py py-class docutils literal notranslate"><span class="pre">Algo</span></code></a></p>
<p>Similar to Rebalance but rebalances to target
weight over n periods.</p>
<p>Rebalances towards a target weight over a n periods. Splits up the weight
delta over n periods.</p>
<p>This can be useful if we want to make more conservative rebalacing
assumptions. Some strategies can produce large swings in allocations. It
might not be reasonable to assume that this rebalancing can occur at the
end of one specific period. Therefore, this algo can be used to simulate
rebalancing over n periods.</p>
<p>This has typically been used in monthly strategies where we want to spread
out the rebalancing over 5 or 10 days.</p>
<dl class="simple">
<dt>Note:</dt><dd><p>This Algo will require the run_always wrapper in the above case. For
example, the RunMonthly will return True on the first day, and
RebalanceOverTime will be ‘armed’. However, RunMonthly will return
False the rest days of the month. Therefore, we must specify that we
want to always run this algo.</p>
</dd>
<dt>Args:</dt><dd><ul class="simple">
<li><p>n (int): number of periods over which rebalancing takes place.</p></li>
</ul>
</dd>
<dt>Requires:</dt><dd><ul class="simple">
<li><p>weights</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="bt.algos.ReplayTransactions">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">bt.algos.</span></span><span class="sig-name descname"><span class="pre">ReplayTransactions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">transactions</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/algos.html#ReplayTransactions"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.algos.ReplayTransactions" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#bt.core.Algo" title="bt.core.Algo"><code class="xref py py-class docutils literal notranslate"><span class="pre">Algo</span></code></a></p>
<p>Replay a list of transactions that were executed.
This is useful for taking a blotter of actual trades that occurred,
and measuring performance against hypothetical strategies.
In particular, one can replay the outputs of backtest.Result.get_transactions</p>
<p>Note that this allows the timestamps and prices of the reported transactions
to be completely arbitrary, so while the strategy may track performance
on a daily basis, it will accurately account for the actual PNL of
the trades based on where they actually traded, and the bidofferpaid
attribute on the strategy will capture the “slippage” as measured
against the daily prices.</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>transactions (str): name of a MultiIndex dataframe with format
Date, Security | quantity, price.
Note this schema follows the output of backtest.Result.get_transactions</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="bt.algos.Require">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">bt.algos.</span></span><span class="sig-name descname"><span class="pre">Require</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pred</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">item</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">if_none</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/algos.html#Require"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.algos.Require" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#bt.core.Algo" title="bt.core.Algo"><code class="xref py py-class docutils literal notranslate"><span class="pre">Algo</span></code></a></p>
<p>Flow control Algo.</p>
<p>This algo returns the value of a predicate
on an temp entry. Useful for controlling
flow.</p>
<p>For example, we might want to make sure we have some items selected.
We could pass a lambda function that checks the len of ‘selected’:</p>
<blockquote>
<div><p>pred=lambda x: len(x) == 0
item=’selected’</p>
</div></blockquote>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>pred (Algo): Function that returns a Bool given the strategy. This
is the definition of an Algo. However, this is typically used
with a simple lambda function.</p></li>
<li><p>item (str): An item within temp.</p></li>
<li><p>if_none (bool): Result if the item required is not in temp or if it’s
value if None</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="bt.algos.ResolveOnTheRun">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">bt.algos.</span></span><span class="sig-name descname"><span class="pre">ResolveOnTheRun</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">on_the_run</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">include_no_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">include_negative</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/algos.html#ResolveOnTheRun"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.algos.ResolveOnTheRun" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#bt.core.Algo" title="bt.core.Algo"><code class="xref py py-class docutils literal notranslate"><span class="pre">Algo</span></code></a></p>
<p>Looks at securities set in temp[‘selected’] and searches for names that
match the names of “aliases” for on-the-run securities in the provided
data. Then replaces the alias with the name of the underlying security
appropriate for the given date, and sets it back on temp[‘selected’]</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><dl class="simple">
<dt>on_the_run (str): Name of a Data frame with</dt><dd><ul>
<li><p>columns set to “on the run” ticker names</p></li>
<li><p>index set to the timeline for the backtest</p></li>
<li><p>values are the actual security name to use for the given date</p></li>
</ul>
</dd>
</dl>
</li>
<li><p>include_no_data (bool): Include securities that do not have data?</p></li>
<li><p>include_negative (bool): Include securities that have negative
or zero prices?</p></li>
</ul>
</dd>
<dt>Requires:</dt><dd><ul class="simple">
<li><p>selected</p></li>
</ul>
</dd>
<dt>Sets:</dt><dd><ul class="simple">
<li><p>selected</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="bt.algos.RollPositionsAfterDates">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">bt.algos.</span></span><span class="sig-name descname"><span class="pre">RollPositionsAfterDates</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">roll_data</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/algos.html#RollPositionsAfterDates"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.algos.RollPositionsAfterDates" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#bt.core.Algo" title="bt.core.Algo"><code class="xref py py-class docutils literal notranslate"><span class="pre">Algo</span></code></a></p>
<p>Roll securities based on the provided map.
This can be used for any securities which have “On-The-Run” and “Off-The-Run”
versions (treasury bonds, index swaps, etc).</p>
<p>Also note that this algo does not operate using temp[‘weights’] and Rebalance.
This is so that hedges (which are excluded from that workflow) will also be
rolled as necessary.</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><dl class="simple">
<dt>roll_data (str): the name of a dataframe indexed by security name, with columns</dt><dd><ul>
<li><p>“date”: the first date at which the roll can occur</p></li>
<li><p>“target”: the security name we are rolling into</p></li>
<li><p>“factor”: the conversion factor. One unit of the original security
rolls into “factor” units of the new one.</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
<dt>Sets:</dt><dd><ul class="simple">
<li><p>target.perm[‘rolled’] : to keep track of which securities have already rolled</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="bt.algos.RunAfterDate">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">bt.algos.</span></span><span class="sig-name descname"><span class="pre">RunAfterDate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">date</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/algos.html#RunAfterDate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.algos.RunAfterDate" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#bt.core.Algo" title="bt.core.Algo"><code class="xref py py-class docutils literal notranslate"><span class="pre">Algo</span></code></a></p>
<p>Returns True after a date has passed</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>date: Date after which to start trading</p></li>
</ul>
</dd>
<dt>Note:</dt><dd><p>This is useful for algos that rely on trailing averages where you
don’t want to start trading until some amount of data has been built up</p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="bt.algos.RunAfterDays">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">bt.algos.</span></span><span class="sig-name descname"><span class="pre">RunAfterDays</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">days</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/algos.html#RunAfterDays"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.algos.RunAfterDays" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#bt.core.Algo" title="bt.core.Algo"><code class="xref py py-class docutils literal notranslate"><span class="pre">Algo</span></code></a></p>
<p>Returns True after a specific number of ‘warmup’ trading days have passed</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>days (int): Number of trading days to wait before starting</p></li>
</ul>
</dd>
<dt>Note:</dt><dd><p>This is useful for algos that rely on trailing averages where you
don’t want to start trading until some amount of data has been built up</p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="bt.algos.RunDaily">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">bt.algos.</span></span><span class="sig-name descname"><span class="pre">RunDaily</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">run_on_first_date</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">run_on_end_of_period</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">run_on_last_date</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/algos.html#RunDaily"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.algos.RunDaily" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#bt.algos.RunPeriod" title="bt.algos.RunPeriod"><code class="xref py py-class docutils literal notranslate"><span class="pre">RunPeriod</span></code></a></p>
<p>Returns True on day change.</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>run_on_first_date (bool): determines if it runs the first time the algo is called</p></li>
<li><p>run_on_end_of_period (bool): determines if it should run at the end of the period
or the beginning</p></li>
<li><p>run_on_last_date (bool): determines if it runs on the last time the algo is called</p></li>
</ul>
</dd>
</dl>
<p>Returns True if the target.now’s day has changed
compared to the last(or next if run_on_end_of_period) date, if not returns False.
Useful for daily rebalancing strategies.</p>
<dl class="py method">
<dt class="sig sig-object py" id="bt.algos.RunDaily.compare_dates">
<span class="sig-name descname"><span class="pre">compare_dates</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">now</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">date_to_compare</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/algos.html#RunDaily.compare_dates"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.algos.RunDaily.compare_dates" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="bt.algos.RunEveryNPeriods">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">bt.algos.</span></span><span class="sig-name descname"><span class="pre">RunEveryNPeriods</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/algos.html#RunEveryNPeriods"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.algos.RunEveryNPeriods" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#bt.core.Algo" title="bt.core.Algo"><code class="xref py py-class docutils literal notranslate"><span class="pre">Algo</span></code></a></p>
<p>This algo runs every n periods.</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>n (int): Run each n periods</p></li>
<li><p>offset (int): Applies to the first run. If 0, this algo will run the
first time it is called.</p></li>
</ul>
</dd>
<dt>This Algo can be useful for the following type of strategy:</dt><dd><p>Each month, select the top 5 performers. Hold them for 3 months.</p>
</dd>
</dl>
<p>You could then create 3 strategies with different offsets and create a
master strategy that would allocate equal amounts of capital to each.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="bt.algos.RunIfOutOfBounds">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">bt.algos.</span></span><span class="sig-name descname"><span class="pre">RunIfOutOfBounds</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tolerance</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/algos.html#RunIfOutOfBounds"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.algos.RunIfOutOfBounds" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#bt.core.Algo" title="bt.core.Algo"><code class="xref py py-class docutils literal notranslate"><span class="pre">Algo</span></code></a></p>
<p>This algo returns true if any of the target weights deviate by an amount greater
than tolerance. For example, it will be run if the tolerance is set to 0.5 and
a security grows from a target weight of 0.2 to greater than 0.3.</p>
<p>A strategy where rebalancing is performed quarterly or whenever any
security’s weight deviates by more than 20% could be implemented by:</p>
<blockquote>
<div><p>Or([runQuarterlyAlgo,runIfOutOfBoundsAlgo(0.2)])</p>
</div></blockquote>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>tolerance (float): Allowed deviation of each security weight.</p></li>
</ul>
</dd>
<dt>Requires:</dt><dd><ul class="simple">
<li><p>Weights</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="bt.algos.RunMonthly">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">bt.algos.</span></span><span class="sig-name descname"><span class="pre">RunMonthly</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">run_on_first_date</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">run_on_end_of_period</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">run_on_last_date</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/algos.html#RunMonthly"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.algos.RunMonthly" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#bt.algos.RunPeriod" title="bt.algos.RunPeriod"><code class="xref py py-class docutils literal notranslate"><span class="pre">RunPeriod</span></code></a></p>
<p>Returns True on month change.</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>run_on_first_date (bool): determines if it runs the first time the algo is called</p></li>
<li><p>run_on_end_of_period (bool): determines if it should run at the end of the period
or the beginning</p></li>
<li><p>run_on_last_date (bool): determines if it runs on the last time the algo is called</p></li>
</ul>
</dd>
</dl>
<p>Returns True if the target.now’s month has changed
since relative to the last(or next) date, if not returns False. Useful for
monthly rebalancing strategies.</p>
<dl class="py method">
<dt class="sig sig-object py" id="bt.algos.RunMonthly.compare_dates">
<span class="sig-name descname"><span class="pre">compare_dates</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">now</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">date_to_compare</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/algos.html#RunMonthly.compare_dates"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.algos.RunMonthly.compare_dates" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="bt.algos.RunOnDate">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">bt.algos.</span></span><span class="sig-name descname"><span class="pre">RunOnDate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">dates</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/algos.html#RunOnDate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.algos.RunOnDate" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#bt.core.Algo" title="bt.core.Algo"><code class="xref py py-class docutils literal notranslate"><span class="pre">Algo</span></code></a></p>
<p>Returns True on a specific set of dates.</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>dates (list): List of dates to run Algo on.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="bt.algos.RunOnce">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">bt.algos.</span></span><span class="sig-name descname"><span class="pre">RunOnce</span></span><a class="reference internal" href="_modules/bt/algos.html#RunOnce"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.algos.RunOnce" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#bt.core.Algo" title="bt.core.Algo"><code class="xref py py-class docutils literal notranslate"><span class="pre">Algo</span></code></a></p>
<p>Returns True on first run then returns False.</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>run_on_first_call: bool which determines if it runs the first time the algo is called</p></li>
</ul>
</dd>
</dl>
<p>As the name says, the algo only runs once. Useful in situations
where we want to run the logic once (buy and hold for example).</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="bt.algos.RunPeriod">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">bt.algos.</span></span><span class="sig-name descname"><span class="pre">RunPeriod</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">run_on_first_date</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">run_on_end_of_period</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">run_on_last_date</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/algos.html#RunPeriod"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.algos.RunPeriod" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#bt.core.Algo" title="bt.core.Algo"><code class="xref py py-class docutils literal notranslate"><span class="pre">Algo</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="bt.algos.RunPeriod.compare_dates">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">compare_dates</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">now</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">date_to_compare</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/algos.html#RunPeriod.compare_dates"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.algos.RunPeriod.compare_dates" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="bt.algos.RunQuarterly">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">bt.algos.</span></span><span class="sig-name descname"><span class="pre">RunQuarterly</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">run_on_first_date</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">run_on_end_of_period</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">run_on_last_date</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/algos.html#RunQuarterly"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.algos.RunQuarterly" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#bt.algos.RunPeriod" title="bt.algos.RunPeriod"><code class="xref py py-class docutils literal notranslate"><span class="pre">RunPeriod</span></code></a></p>
<p>Returns True on quarter change.</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>run_on_first_date (bool): determines if it runs the first time the algo is called</p></li>
<li><p>run_on_end_of_period (bool): determines if it should run at the end of the period
or the beginning</p></li>
<li><p>run_on_last_date (bool): determines if it runs on the last time the algo is called</p></li>
</ul>
</dd>
</dl>
<p>Returns True if the target.now’s quarter has changed
since relative to the last(or next) date, if not returns False. Useful for
quarterly rebalancing strategies.</p>
<dl class="py method">
<dt class="sig sig-object py" id="bt.algos.RunQuarterly.compare_dates">
<span class="sig-name descname"><span class="pre">compare_dates</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">now</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">date_to_compare</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/algos.html#RunQuarterly.compare_dates"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.algos.RunQuarterly.compare_dates" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="bt.algos.RunWeekly">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">bt.algos.</span></span><span class="sig-name descname"><span class="pre">RunWeekly</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">run_on_first_date</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">run_on_end_of_period</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">run_on_last_date</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/algos.html#RunWeekly"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.algos.RunWeekly" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#bt.algos.RunPeriod" title="bt.algos.RunPeriod"><code class="xref py py-class docutils literal notranslate"><span class="pre">RunPeriod</span></code></a></p>
<p>Returns True on week change.</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>run_on_first_date (bool): determines if it runs the first time the algo is called</p></li>
<li><p>run_on_end_of_period (bool): determines if it should run at the end of the period
or the beginning</p></li>
<li><p>run_on_last_date (bool): determines if it runs on the last time the algo is called</p></li>
</ul>
</dd>
</dl>
<p>Returns True if the target.now’s week has changed
since relative to the last(or next) date, if not returns False. Useful for
weekly rebalancing strategies.</p>
<dl class="py method">
<dt class="sig sig-object py" id="bt.algos.RunWeekly.compare_dates">
<span class="sig-name descname"><span class="pre">compare_dates</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">now</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">date_to_compare</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/algos.html#RunWeekly.compare_dates"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.algos.RunWeekly.compare_dates" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="bt.algos.RunYearly">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">bt.algos.</span></span><span class="sig-name descname"><span class="pre">RunYearly</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">run_on_first_date</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">run_on_end_of_period</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">run_on_last_date</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/algos.html#RunYearly"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.algos.RunYearly" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#bt.algos.RunPeriod" title="bt.algos.RunPeriod"><code class="xref py py-class docutils literal notranslate"><span class="pre">RunPeriod</span></code></a></p>
<p>Returns True on year change.</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>run_on_first_date (bool): determines if it runs the first time the algo is called</p></li>
<li><p>run_on_end_of_period (bool): determines if it should run at the end of the period
or the beginning</p></li>
<li><p>run_on_last_date (bool): determines if it runs on the last time the algo is called</p></li>
</ul>
</dd>
</dl>
<p>Returns True if the target.now’s year has changed
since relative to the last(or next) date, if not returns False. Useful for
yearly rebalancing strategies.</p>
<dl class="py method">
<dt class="sig sig-object py" id="bt.algos.RunYearly.compare_dates">
<span class="sig-name descname"><span class="pre">compare_dates</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">now</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">date_to_compare</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/algos.html#RunYearly.compare_dates"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.algos.RunYearly.compare_dates" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="bt.algos.ScaleWeights">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">bt.algos.</span></span><span class="sig-name descname"><span class="pre">ScaleWeights</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scale</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/algos.html#ScaleWeights"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.algos.ScaleWeights" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#bt.core.Algo" title="bt.core.Algo"><code class="xref py py-class docutils literal notranslate"><span class="pre">Algo</span></code></a></p>
<p>Sets temp[‘weights’] based on a scaled version of itself.
Useful for going short, or scaling up/down when using
<a class="reference internal" href="#bt.core.FixedIncomeStrategy" title="bt.core.FixedIncomeStrategy"><code class="xref py py-class docutils literal notranslate"><span class="pre">FixedIncomeStrategy</span></code></a>.</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>scale (float): the scaling factor</p></li>
</ul>
</dd>
<dt>Sets:</dt><dd><ul class="simple">
<li><p>weights</p></li>
</ul>
</dd>
<dt>Requires:</dt><dd><ul class="simple">
<li><p>weights</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="bt.algos.SelectActive">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">bt.algos.</span></span><span class="sig-name descname"><span class="pre">SelectActive</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/algos.html#SelectActive"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.algos.SelectActive" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#bt.core.Algo" title="bt.core.Algo"><code class="xref py py-class docutils literal notranslate"><span class="pre">Algo</span></code></a></p>
<p>Sets temp[‘selected’] based on filtering temp[‘selected’] to exclude
those securities that have been closed or rolled after a certain date
using ClosePositionsAfterDates or RollPositionsAfterDates. This makes sure
not to select them again for weighting (even if they have prices).</p>
<dl class="simple">
<dt>Requires:</dt><dd><ul class="simple">
<li><p>selected</p></li>
<li><p>perm[‘closed’] or perm[‘rolled’]</p></li>
</ul>
</dd>
<dt>Sets:</dt><dd><ul class="simple">
<li><p>selected</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="bt.algos.SelectAll">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">bt.algos.</span></span><span class="sig-name descname"><span class="pre">SelectAll</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">include_no_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">include_negative</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/algos.html#SelectAll"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.algos.SelectAll" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#bt.core.Algo" title="bt.core.Algo"><code class="xref py py-class docutils literal notranslate"><span class="pre">Algo</span></code></a></p>
<p>Sets temp[‘selected’] with all securities (based on universe).</p>
<p>Selects all the securities and saves them in temp[‘selected’].
By default, SelectAll does not include securities that have no
data (nan) on current date or those whose price is zero or negative.</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>include_no_data (bool): Include securities that do not have data?</p></li>
<li><p>include_negative (bool): Include securities that have negative
or zero prices?</p></li>
</ul>
</dd>
<dt>Sets:</dt><dd><ul class="simple">
<li><p>selected</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="bt.algos.SelectHasData">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">bt.algos.</span></span><span class="sig-name descname"><span class="pre">SelectHasData</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lookback=&lt;DateOffset:</span> <span class="pre">months=3&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_count=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">include_no_data=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">include_negative=False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/algos.html#SelectHasData"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.algos.SelectHasData" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#bt.core.Algo" title="bt.core.Algo"><code class="xref py py-class docutils literal notranslate"><span class="pre">Algo</span></code></a></p>
<p>Sets temp[‘selected’] based on all items in universe that meet
data requirements.</p>
<p>This is a more advanced version of SelectAll. Useful for selecting
tickers that need a certain amount of data for future algos to run
properly.</p>
<p>For example, if we need the items with 3 months of data or more,
we could use this Algo with a lookback period of 3 months.</p>
<p>When providing a lookback period, it is also wise to provide a min_count.
This is basically the number of data points needed within the lookback
period for a series to be considered valid. For example, in our 3 month
lookback above, we might want to specify the min_count as being
57 -&gt; a typical trading month has give or take 20 trading days. If we
factor in some holidays, we can use 57 or 58. It’s really up to you.</p>
<p>If you don’t specify min_count, min_count will default to ffn’s
get_num_days_required.</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>lookback (DateOffset): A DateOffset that determines the lookback
period.</p></li>
<li><p>min_count (int): Minimum number of days required for a series to be
considered valid. If not provided, ffn’s get_num_days_required is
used to estimate the number of points required.</p></li>
<li><p>include_no_data (bool): Include securities that do not have data?</p></li>
<li><p>include_negative (bool): Include securities that have negative
or zero prices?</p></li>
</ul>
</dd>
<dt>Sets:</dt><dd><ul class="simple">
<li><p>selected</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="bt.algos.SelectMomentum">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">bt.algos.</span></span><span class="sig-name descname"><span class="pre">SelectMomentum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lookback=&lt;DateOffset:</span> <span class="pre">months=3&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lag=&lt;DateOffset:</span> <span class="pre">days=0&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sort_descending=True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">all_or_none=False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/algos.html#SelectMomentum"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.algos.SelectMomentum" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#bt.core.AlgoStack" title="bt.core.AlgoStack"><code class="xref py py-class docutils literal notranslate"><span class="pre">AlgoStack</span></code></a></p>
<p>Sets temp[‘selected’] based on a simple momentum filter.</p>
<p>Selects the top n securities based on the total return over
a given lookback period. This is just a wrapper around an
AlgoStack with two algos: StatTotalReturn and SelectN.</p>
<p>Note, that SelectAll() or similar should be called before
SelectMomentum(), as StatTotalReturn uses values of temp[‘selected’]</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>n (int): select first N elements</p></li>
<li><p>lookback (DateOffset): lookback period for total return
calculation</p></li>
<li><p>lag (DateOffset): Lag interval for total return calculation</p></li>
<li><p>sort_descending (bool): Sort descending (highest return is best)</p></li>
<li><p>all_or_none (bool): If true, only populates temp[‘selected’] if we
have n items. If we have less than n, then temp[‘selected’] = [].</p></li>
</ul>
</dd>
<dt>Sets:</dt><dd><ul class="simple">
<li><p>selected</p></li>
</ul>
</dd>
<dt>Requires:</dt><dd><ul class="simple">
<li><p>selected</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="bt.algos.SelectN">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">bt.algos.</span></span><span class="sig-name descname"><span class="pre">SelectN</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sort_descending</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">all_or_none</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_selected</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/algos.html#SelectN"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.algos.SelectN" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#bt.core.Algo" title="bt.core.Algo"><code class="xref py py-class docutils literal notranslate"><span class="pre">Algo</span></code></a></p>
<p>Sets temp[‘selected’] based on ranking temp[‘stat’].</p>
<p>Selects the top or botton N items based on temp[‘stat’].
This is usually some kind of metric that will be computed in a
previous Algo and will be used for ranking purposes. Can select
top or bottom N based on sort_descending parameter.</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>n (int): select top n items.</p></li>
<li><p>sort_descending (bool): Should the stat be sorted in descending order
before selecting the first n items?</p></li>
<li><p>all_or_none (bool): If true, only populates temp[‘selected’] if we
have n items. If we have less than n, then temp[‘selected’] = [].</p></li>
<li><p>filter_selected (bool): If True, will only select from the existing
‘selected’ list.</p></li>
</ul>
</dd>
<dt>Sets:</dt><dd><ul class="simple">
<li><p>selected</p></li>
</ul>
</dd>
<dt>Requires:</dt><dd><ul class="simple">
<li><p>stat</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="bt.algos.SelectRandomly">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">bt.algos.</span></span><span class="sig-name descname"><span class="pre">SelectRandomly</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">include_no_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">include_negative</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/algos.html#SelectRandomly"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.algos.SelectRandomly" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#bt.core.AlgoStack" title="bt.core.AlgoStack"><code class="xref py py-class docutils literal notranslate"><span class="pre">AlgoStack</span></code></a></p>
<p>Sets temp[‘selected’] based on a random subset of
the items currently in temp[‘selected’].</p>
<p>Selects n random elements from the list stored in temp[‘selected’].
This is useful for benchmarking against a strategy where we believe
the selection algorithm is adding value.</p>
<p>For example, if we are testing a momentum strategy and we want to see if
selecting securities based on momentum is better than just selecting
securities randomly, we could use this Algo to create a random Strategy
used for random benchmarking.</p>
<dl class="simple">
<dt>Note:</dt><dd><p>Another selection algorithm should be use prior to this Algo to
populate temp[‘selected’]. This will typically be SelectAll.</p>
</dd>
<dt>Args:</dt><dd><ul class="simple">
<li><p>n (int): Select N elements randomly.</p></li>
<li><p>include_no_data (bool): Include securities that do not have data?</p></li>
<li><p>include_negative (bool): Include securities that have negative
or zero prices?</p></li>
</ul>
</dd>
<dt>Sets:</dt><dd><ul class="simple">
<li><p>selected</p></li>
</ul>
</dd>
<dt>Requires:</dt><dd><ul class="simple">
<li><p>selected</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="bt.algos.SelectRegex">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">bt.algos.</span></span><span class="sig-name descname"><span class="pre">SelectRegex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">regex</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/algos.html#SelectRegex"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.algos.SelectRegex" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#bt.core.Algo" title="bt.core.Algo"><code class="xref py py-class docutils literal notranslate"><span class="pre">Algo</span></code></a></p>
<p>Sets temp[‘selected’] based on a regex on their names.
Useful when working with a large universe of different kinds of securities</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>regex (str): regular expression on the name</p></li>
</ul>
</dd>
<dt>Sets:</dt><dd><ul class="simple">
<li><p>selected</p></li>
</ul>
</dd>
<dt>Requires:</dt><dd><ul class="simple">
<li><p>selected</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="bt.algos.SelectThese">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">bt.algos.</span></span><span class="sig-name descname"><span class="pre">SelectThese</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tickers</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">include_no_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">include_negative</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/algos.html#SelectThese"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.algos.SelectThese" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#bt.core.Algo" title="bt.core.Algo"><code class="xref py py-class docutils literal notranslate"><span class="pre">Algo</span></code></a></p>
<p>Sets temp[‘selected’] with a set list of tickers.</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>ticker (list): List of tickers to select.</p></li>
<li><p>include_no_data (bool): Include securities that do not have data?</p></li>
<li><p>include_negative (bool): Include securities that have negative
or zero prices?</p></li>
</ul>
</dd>
<dt>Sets:</dt><dd><ul class="simple">
<li><p>selected</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="bt.algos.SelectTypes">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">bt.algos.</span></span><span class="sig-name descname"><span class="pre">SelectTypes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">include_types=(&lt;class</span> <span class="pre">'bt.core.Node'&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exclude_types=()</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/algos.html#SelectTypes"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.algos.SelectTypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#bt.core.Algo" title="bt.core.Algo"><code class="xref py py-class docutils literal notranslate"><span class="pre">Algo</span></code></a></p>
<p>Sets temp[‘selected’] based on node type.
If temp[‘selected’] is already set, it will filter the existing
selection.</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>include_types (list): Types of nodes to include</p></li>
<li><p>exclude_types (list): Types of nodes to exclude</p></li>
</ul>
</dd>
<dt>Sets:</dt><dd><ul class="simple">
<li><p>selected</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="bt.algos.SelectWhere">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">bt.algos.</span></span><span class="sig-name descname"><span class="pre">SelectWhere</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">include_no_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">include_negative</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/algos.html#SelectWhere"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.algos.SelectWhere" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#bt.core.Algo" title="bt.core.Algo"><code class="xref py py-class docutils literal notranslate"><span class="pre">Algo</span></code></a></p>
<p>Selects securities based on an indicator DataFrame.</p>
<p>Selects securities where the value is True on the current date
(target.now) only if current date is present in signal DataFrame.</p>
<p>For example, this could be the result of a pandas boolean comparison such
as data &gt; 100.</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>signal (str|DataFrame): Boolean DataFrame containing selection logic.
If a string is passed, frame is accessed using target.get_data
This is the preferred way of using the algo.</p></li>
<li><p>include_no_data (bool): Include securities that do not have data?</p></li>
<li><p>include_negative (bool): Include securities that have negative
or zero prices?</p></li>
</ul>
</dd>
<dt>Sets:</dt><dd><ul class="simple">
<li><p>selected</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="bt.algos.SetNotional">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">bt.algos.</span></span><span class="sig-name descname"><span class="pre">SetNotional</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">notional_value</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/algos.html#SetNotional"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.algos.SetNotional" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#bt.core.Algo" title="bt.core.Algo"><code class="xref py py-class docutils literal notranslate"><span class="pre">Algo</span></code></a></p>
<p>Sets the notional_value to use as the base for rebalancing for
<a class="reference internal" href="#bt.core.FixedIncomeStrategy" title="bt.core.FixedIncomeStrategy"><code class="xref py py-class docutils literal notranslate"><span class="pre">FixedIncomeStrategy</span></code></a> targets</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>notional_value (str): Name of a pd.Series object containing the
target notional values of the strategy over time.</p></li>
</ul>
</dd>
<dt>Sets:</dt><dd><ul class="simple">
<li><p>notional_value</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="bt.algos.SetStat">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">bt.algos.</span></span><span class="sig-name descname"><span class="pre">SetStat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">stat</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/algos.html#SetStat"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.algos.SetStat" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#bt.core.Algo" title="bt.core.Algo"><code class="xref py py-class docutils literal notranslate"><span class="pre">Algo</span></code></a></p>
<p>Sets temp[‘stat’] for use by downstream algos (such as SelectN).</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>stat (str|DataFrame): A dataframe of the same dimension as target.universe
If a string is passed, frame is accessed using target.get_data
This is the preferred way of using the algo.</p></li>
</ul>
</dd>
<dt>Sets:</dt><dd><ul class="simple">
<li><p>stat</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="bt.algos.SimulateRFQTransactions">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">bt.algos.</span></span><span class="sig-name descname"><span class="pre">SimulateRFQTransactions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rfqs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/algos.html#SimulateRFQTransactions"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.algos.SimulateRFQTransactions" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#bt.core.Algo" title="bt.core.Algo"><code class="xref py py-class docutils literal notranslate"><span class="pre">Algo</span></code></a></p>
<p>An algo that simulates the outcomes from RFQs (Request for Quote)
using a “model” that determines which ones becomes transactions and at what price
those transactions happen. This can be used from the perspective of the sender of the
RFQ or the receiver.</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>rfqs (str): name of a dataframe with columns
Date, Security | quantity, <a href="#id2"><span class="problematic" id="id3">*</span></a>additional columns as required by model</p></li>
<li><dl class="simple">
<dt>model (object): a function/callable object with arguments</dt><dd><ul>
<li><p>rfqs : data frame of rfqs to respond to</p></li>
<li><p>target : the strategy object, for access to position and value data</p></li>
</ul>
</dd>
<dt>and which returns a set of transactions, a MultiIndex DataFrame with:</dt><dd><p>Date, Security | quantity, price</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="bt.algos.StatTotalReturn">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">bt.algos.</span></span><span class="sig-name descname"><span class="pre">StatTotalReturn</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lookback=&lt;DateOffset:</span> <span class="pre">months=3&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lag=&lt;DateOffset:</span> <span class="pre">days=0&gt;</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/algos.html#StatTotalReturn"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.algos.StatTotalReturn" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#bt.core.Algo" title="bt.core.Algo"><code class="xref py py-class docutils literal notranslate"><span class="pre">Algo</span></code></a></p>
<p>Sets temp[‘stat’] with total returns over a given period.</p>
<p>Sets the ‘stat’ based on the total return of each element in
temp[‘selected’] over a given lookback period. The total return
is determined by ffn’s calc_total_return.</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>lookback (DateOffset): lookback period.</p></li>
<li><p>lag (DateOffset): Lag interval. Total return is calculated in
the inteval [now - lookback - lag, now - lag]</p></li>
</ul>
</dd>
<dt>Sets:</dt><dd><ul class="simple">
<li><p>stat</p></li>
</ul>
</dd>
<dt>Requires:</dt><dd><ul class="simple">
<li><p>selected</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="bt.algos.TargetVol">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">bt.algos.</span></span><span class="sig-name descname"><span class="pre">TargetVol</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">target_volatility</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lookback=&lt;DateOffset:</span> <span class="pre">months=3&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lag=&lt;DateOffset:</span> <span class="pre">days=0&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">covar_method='standard'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">annualization_factor=252</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/algos.html#TargetVol"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.algos.TargetVol" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#bt.core.Algo" title="bt.core.Algo"><code class="xref py py-class docutils literal notranslate"><span class="pre">Algo</span></code></a></p>
<p>Updates temp[‘weights’] based on the target annualized volatility desired.</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>target_volatility: annualized volatility to target</p></li>
<li><p>lookback (DateOffset): lookback period for estimating volatility</p></li>
<li><p>lag (DateOffset): amount of time to wait to calculate the covariance</p></li>
<li><p>covar_method: method of calculating volatility</p></li>
<li><p>annualization_factor: number of periods to annualize by.
It is assumed that target volatility is already annualized by this factor.</p></li>
</ul>
</dd>
<dt>Updates:</dt><dd><ul class="simple">
<li><p>weights</p></li>
</ul>
</dd>
<dt>Requires:</dt><dd><ul class="simple">
<li><p>temp[‘weights’]</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="bt.algos.UpdateRisk">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">bt.algos.</span></span><span class="sig-name descname"><span class="pre">UpdateRisk</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">measure</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">history</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/algos.html#UpdateRisk"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.algos.UpdateRisk" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#bt.core.Algo" title="bt.core.Algo"><code class="xref py py-class docutils literal notranslate"><span class="pre">Algo</span></code></a></p>
<p>Tracks a risk measure on all nodes of the strategy. To use this node, the
<code class="docutils literal notranslate"><span class="pre">additional_data</span></code> argument on <a class="reference internal" href="#bt.backtest.Backtest" title="bt.backtest.Backtest"><code class="xref py py-class docutils literal notranslate"><span class="pre">Backtest</span></code></a> must
have a “unit_risk” key. The value should be a dictionary, keyed
by risk measure, of DataFrames with a column per security that is sensitive to that measure.</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>name (str): the name of the risk measure (IR01, PVBP, IsIndustials, etc).
The name must coincide with the keys of the dictionary passed to additional_data as the
“unit_risk” argument.</p></li>
<li><p>history (int): The level of depth in the tree at which to track the time series of risk numbers.
i.e. 0=no tracking, 1=first level only, etc. More levels is more expensive.</p></li>
</ul>
</dd>
<dt>Modifies:</dt><dd><ul class="simple">
<li><p>The “risk” attribute on the target and all its children</p></li>
<li><p>If history==True, the “risks” attribute on the target and all its children</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="bt.algos.WeighERC">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">bt.algos.</span></span><span class="sig-name descname"><span class="pre">WeighERC</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lookback=&lt;DateOffset:</span> <span class="pre">months=3&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial_weights=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">risk_weights=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">covar_method='ledoit-wolf'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">risk_parity_method='ccd'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maximum_iterations=100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance=1e-08</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lag=&lt;DateOffset:</span> <span class="pre">days=0&gt;</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/algos.html#WeighERC"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.algos.WeighERC" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#bt.core.Algo" title="bt.core.Algo"><code class="xref py py-class docutils literal notranslate"><span class="pre">Algo</span></code></a></p>
<p>Sets temp[‘weights’] based on equal risk contribution algorithm.</p>
<p>Sets the target weights based on ffn’s calc_erc_weights. This
is an extension of the inverse volatility risk parity portfolio in
which the correlation of asset returns is incorporated into the
calculation of risk contribution of each asset.</p>
<p>The resulting portfolio is similar to a minimum variance portfolio
subject to a diversification constraint on the weights of its components
and its volatility is located between those of the minimum variance and
equally-weighted portfolios (Maillard 2008).</p>
<dl class="simple">
<dt>See:</dt><dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Risk_parity">https://en.wikipedia.org/wiki/Risk_parity</a></p>
</dd>
<dt>Args:</dt><dd><ul class="simple">
<li><p>lookback (DateOffset): lookback period for estimating covariance</p></li>
<li><p>initial_weights (list): Starting asset weights [default inverse vol].</p></li>
<li><p>risk_weights (list): Risk target weights [default equal weight].</p></li>
<li><p>covar_method (str): method used to estimate the covariance. See ffn’s
calc_erc_weights for more details. (default ledoit-wolf).</p></li>
<li><p>risk_parity_method (str): Risk parity estimation method. see ffn’s
calc_erc_weights for more details. (default ccd).</p></li>
<li><p>maximum_iterations (int): Maximum iterations in iterative solutions
(default 100).</p></li>
<li><p>tolerance (float): Tolerance level in iterative solutions (default 1E-8).</p></li>
</ul>
</dd>
<dt>Sets:</dt><dd><ul class="simple">
<li><p>weights</p></li>
</ul>
</dd>
<dt>Requires:</dt><dd><ul class="simple">
<li><p>selected</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="bt.algos.WeighEqually">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">bt.algos.</span></span><span class="sig-name descname"><span class="pre">WeighEqually</span></span><a class="reference internal" href="_modules/bt/algos.html#WeighEqually"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.algos.WeighEqually" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#bt.core.Algo" title="bt.core.Algo"><code class="xref py py-class docutils literal notranslate"><span class="pre">Algo</span></code></a></p>
<p>Sets temp[‘weights’] by calculating equal weights for all items in
selected.</p>
<p>Equal weight Algo. Sets the ‘weights’ to 1/n for each item in ‘selected’.</p>
<dl class="simple">
<dt>Sets:</dt><dd><ul class="simple">
<li><p>weights</p></li>
</ul>
</dd>
<dt>Requires:</dt><dd><ul class="simple">
<li><p>selected</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="bt.algos.WeighInvVol">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">bt.algos.</span></span><span class="sig-name descname"><span class="pre">WeighInvVol</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lookback=&lt;DateOffset:</span> <span class="pre">months=3&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lag=&lt;DateOffset:</span> <span class="pre">days=0&gt;</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/algos.html#WeighInvVol"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.algos.WeighInvVol" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#bt.core.Algo" title="bt.core.Algo"><code class="xref py py-class docutils literal notranslate"><span class="pre">Algo</span></code></a></p>
<p>Sets temp[‘weights’] based on the inverse volatility Algo.</p>
<p>Sets the target weights based on ffn’s calc_inv_vol_weights. This
is a commonly used technique for risk parity portfolios. The least
volatile elements receive the highest weight under this scheme. Weights
are proportional to the inverse of their volatility.</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>lookback (DateOffset): lookback period for estimating volatility</p></li>
</ul>
</dd>
<dt>Sets:</dt><dd><ul class="simple">
<li><p>weights</p></li>
</ul>
</dd>
<dt>Requires:</dt><dd><ul class="simple">
<li><p>selected</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="bt.algos.WeighMeanVar">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">bt.algos.</span></span><span class="sig-name descname"><span class="pre">WeighMeanVar</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lookback=&lt;DateOffset:</span> <span class="pre">months=3&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bounds=(0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">1.0)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">covar_method='ledoit-wolf'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rf=0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lag=&lt;DateOffset:</span> <span class="pre">days=0&gt;</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/algos.html#WeighMeanVar"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.algos.WeighMeanVar" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#bt.core.Algo" title="bt.core.Algo"><code class="xref py py-class docutils literal notranslate"><span class="pre">Algo</span></code></a></p>
<p>Sets temp[‘weights’] based on mean-variance optimization.</p>
<p>Sets the target weights based on ffn’s calc_mean_var_weights. This is a
Python implementation of Markowitz’s mean-variance optimization.</p>
<dl class="simple">
<dt>See:</dt><dd><p><a class="reference external" href="http://en.wikipedia.org/wiki/Modern_portfolio_theory#The_efficient_frontier_with_no_risk-free_asset">http://en.wikipedia.org/wiki/Modern_portfolio_theory#The_efficient_frontier_with_no_risk-free_asset</a></p>
</dd>
<dt>Args:</dt><dd><ul class="simple">
<li><p>lookback (DateOffset): lookback period for estimating volatility</p></li>
<li><p>bounds ((min, max)): tuple specifying the min and max weights for
each asset in the optimization.</p></li>
<li><p>covar_method (str): method used to estimate the covariance. See ffn’s
calc_mean_var_weights for more details.</p></li>
<li><p>rf (float): risk-free rate used in optimization.</p></li>
</ul>
</dd>
<dt>Sets:</dt><dd><ul class="simple">
<li><p>weights</p></li>
</ul>
</dd>
<dt>Requires:</dt><dd><ul class="simple">
<li><p>selected</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="bt.algos.WeighRandomly">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">bt.algos.</span></span><span class="sig-name descname"><span class="pre">WeighRandomly</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bounds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(0.0,</span> <span class="pre">1.0)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight_sum</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/algos.html#WeighRandomly"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.algos.WeighRandomly" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#bt.core.Algo" title="bt.core.Algo"><code class="xref py py-class docutils literal notranslate"><span class="pre">Algo</span></code></a></p>
<p>Sets temp[‘weights’] based on a random weight vector.</p>
<p>Sets random target weights for each security in ‘selected’.
This is useful for benchmarking against a strategy where we believe
the weighing algorithm is adding value.</p>
<p>For example, if we are testing a low-vol strategy and we want to see if
our weighing strategy is better than just weighing
securities randomly, we could use this Algo to create a random Strategy
used for random benchmarking.</p>
<p>This is an Algo wrapper around ffn’s random_weights function.</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>bounds ((low, high)): Tuple including low and high bounds for each
security</p></li>
<li><p>weight_sum (float): What should the weights sum up to?</p></li>
</ul>
</dd>
<dt>Sets:</dt><dd><ul class="simple">
<li><p>weights</p></li>
</ul>
</dd>
<dt>Requires:</dt><dd><ul class="simple">
<li><p>selected</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="bt.algos.WeighSpecified">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">bt.algos.</span></span><span class="sig-name descname"><span class="pre">WeighSpecified</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">weights</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/algos.html#WeighSpecified"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.algos.WeighSpecified" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#bt.core.Algo" title="bt.core.Algo"><code class="xref py py-class docutils literal notranslate"><span class="pre">Algo</span></code></a></p>
<p>Sets temp[‘weights’] based on a provided dict of ticker:weights.</p>
<p>Sets the weights based on pre-specified targets.</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>weights (dict): target weights -&gt; ticker: weight</p></li>
</ul>
</dd>
<dt>Sets:</dt><dd><ul class="simple">
<li><p>weights</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="bt.algos.WeighTarget">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">bt.algos.</span></span><span class="sig-name descname"><span class="pre">WeighTarget</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">weights</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/algos.html#WeighTarget"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.algos.WeighTarget" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#bt.core.Algo" title="bt.core.Algo"><code class="xref py py-class docutils literal notranslate"><span class="pre">Algo</span></code></a></p>
<p>Sets target weights based on a target weight DataFrame.</p>
<p>If the target weight dataFrame is  of same dimension
as the target.universe, the portfolio will effectively be rebalanced on
each period. For example, if we have daily data and the target DataFrame
is of the same shape, we will have daily rebalancing.</p>
<p>However, if we provide a target weight dataframe that has only month end
dates, then rebalancing only occurs monthly.</p>
<p>Basically, if a weight is provided on a given date, the target weights are
set and the algo moves on (presumably to a Rebalance algo). If not, not
target weights are set.</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>weights (str|DataFrame): DataFrame containing the target weights
If a string is passed, frame is accessed using target.get_data
This is the preferred way of using the algo.</p></li>
</ul>
</dd>
<dt>Sets:</dt><dd><ul class="simple">
<li><p>weights</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="bt.algos.run_always">
<span class="sig-prename descclassname"><span class="pre">bt.algos.</span></span><span class="sig-name descname"><span class="pre">run_always</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">f</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/algos.html#run_always"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.algos.run_always" title="Permalink to this definition">¶</a></dt>
<dd><p>Run always decorator to be used with Algo
to ensure stack runs the decorated Algo
on each pass, regardless of failures in the stack.</p>
</dd></dl>

</div>
<div class="section" id="module-bt.backtest">
<span id="backtest-module"></span><h2><code class="xref py py-mod docutils literal notranslate"><span class="pre">backtest</span></code> Module<a class="headerlink" href="#module-bt.backtest" title="Permalink to this heading">¶</a></h2>
<p>Contains backtesting logic and objects.</p>
<dl class="py class">
<dt class="sig sig-object py" id="bt.backtest.Backtest">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">bt.backtest.</span></span><span class="sig-name descname"><span class="pre">Backtest</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">strategy</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial_capital</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000000.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">commissions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">integer_positions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">progress_bar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">additional_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/backtest.html#Backtest"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.backtest.Backtest" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A Backtest combines a Strategy with data to
produce a Result.</p>
<p>A backtest is basically testing a strategy over a data set.</p>
<dl>
<dt>Note:</dt><dd><p>The Strategy will be deepcopied so it is re-usable in other
backtests. To access the backtested strategy, simply access
the strategy attribute.</p>
</dd>
<dt>Args:</dt><dd><ul>
<li><p>strategy (Strategy, Node, StrategyBase): The Strategy to be tested.</p></li>
<li><p>data (DataFrame): DataFrame containing data used in backtest. This
will be the Strategy’s “universe”.</p></li>
<li><p>name (str): Backtest name - defaults to strategy name</p></li>
<li><p>initial_capital (float): Initial amount of capital passed to
Strategy.</p></li>
<li><p>commissions (fn(quantity, price)): The commission function
to be used. Ex: commissions=lambda q, p: max(1, abs(q) * 0.01)</p></li>
<li><p>integer_positions (bool): Whether to use integer positions for securities
in the backtest. This can have unintended consequences when prices are
high relative to the amount of capital (i.e. though split-adjusted prices,
or too-low of a capital amount), causing allocated positions to round to zero.
While the default is True, try setting to False for more robust behavior.</p></li>
<li><p>progress_bar (Bool): Display progress bar while running backtest</p></li>
<li><p>additional_data (dict): Additional kwargs passed to StrategyBase.setup, after preprocessing
This data can be retrieved by Algos using StrategyBase.get_data.
The data may also be used by the Strategy itself, i.e.</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">bidoffer</span></code>: A DataFrame with the same format as ‘data’, will be used
by the strategy for transaction cost modeling</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">coupons</span></code>: A DataFrame with the same format as ‘data’, will by used
by <a class="reference internal" href="#bt.core.CouponPayingSecurity" title="bt.core.CouponPayingSecurity"><code class="xref py py-class docutils literal notranslate"><span class="pre">CouponPayingSecurity</span></code></a>
to determine cashflows.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">cost_long</span></code>/<code class="docutils literal notranslate"><span class="pre">cost_short</span></code>: A DataFrame with the same format as ‘data’,
will by used
by <a class="reference internal" href="#bt.core.CouponPayingSecurity" title="bt.core.CouponPayingSecurity"><code class="xref py py-class docutils literal notranslate"><span class="pre">CouponPayingSecurity</span></code></a>
to calculate asymmetric holding cost of long (or short) positions.</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</dd>
<dt>Attributes:</dt><dd><ul class="simple">
<li><p>strategy (Strategy): The Backtest’s Strategy. This will be a deepcopy
of the Strategy that was passed in.</p></li>
<li><p>data (DataFrame): Data passed in</p></li>
<li><p>dates (DateTimeIndex): Data’s index</p></li>
<li><p>initial_capital (float): Initial capital</p></li>
<li><p>name (str): Backtest name</p></li>
<li><p>stats (ffn.PerformanceStats): Performance statistics</p></li>
<li><p>has_run (bool): Run flag</p></li>
<li><p>weights (DataFrame): Weights of each component over time</p></li>
<li><p>security_weights (DataFrame): Weights of each security as a
percentage of the whole portfolio over time</p></li>
<li><p>additional_data (dict): Additional data passed at construction</p></li>
</ul>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="bt.backtest.Backtest.herfindahl_index">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">herfindahl_index</span></span><a class="headerlink" href="#bt.backtest.Backtest.herfindahl_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate Herfindahl-Hirschman Index (HHI) for the portfolio.
For each given day, HHI is defined as a sum of squared weights of
securities in a portfolio; and varies from 1/N to 1.
Value of 1/N would correspond to an equally weighted portfolio and
value of 1 corresponds to an extreme case when all amount is invested
in a single asset.</p>
<p>1 / HHI is often considered as “an effective number of assets” in
a given portfolio</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="bt.backtest.Backtest.positions">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">positions</span></span><a class="headerlink" href="#bt.backtest.Backtest.positions" title="Permalink to this definition">¶</a></dt>
<dd><p>DataFrame of each component’s position over time</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="bt.backtest.Backtest.run">
<span class="sig-name descname"><span class="pre">run</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/backtest.html#Backtest.run"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.backtest.Backtest.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Runs the Backtest.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="bt.backtest.Backtest.security_weights">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">security_weights</span></span><a class="headerlink" href="#bt.backtest.Backtest.security_weights" title="Permalink to this definition">¶</a></dt>
<dd><p>DataFrame containing weights of each security as a
percentage of the whole portfolio over time</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="bt.backtest.Backtest.turnover">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">turnover</span></span><a class="headerlink" href="#bt.backtest.Backtest.turnover" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the turnover for the backtest.</p>
<p>This function will calculate the turnover for the strategy. Turnover is
defined as the lesser of positive or negative outlays divided by NAV</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="bt.backtest.Backtest.weights">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">weights</span></span><a class="headerlink" href="#bt.backtest.Backtest.weights" title="Permalink to this definition">¶</a></dt>
<dd><p>DataFrame of each component’s weight over time</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="bt.backtest.RandomBenchmarkResult">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">bt.backtest.</span></span><span class="sig-name descname"><span class="pre">RandomBenchmarkResult</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">backtests</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/backtest.html#RandomBenchmarkResult"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.backtest.RandomBenchmarkResult" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#bt.backtest.Result" title="bt.backtest.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">Result</span></code></a></p>
<p>RandomBenchmarkResult expands on Result to add methods specific
to random strategy benchmarking.</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>backtests (list): List of backtests</p></li>
</ul>
</dd>
<dt>Attributes:</dt><dd><ul class="simple">
<li><p>base_name (str): Name of backtest being benchmarked</p></li>
<li><p>r_stats (Result): Stats for random strategies</p></li>
<li><p>b_stats (Result): Stats for benchmarked strategy</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="bt.backtest.RandomBenchmarkResult.plot_histogram">
<span class="sig-name descname"><span class="pre">plot_histogram</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">statistic</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'monthly_sharpe'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">figsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(15,</span> <span class="pre">5)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">title</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bins</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/backtest.html#RandomBenchmarkResult.plot_histogram"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.backtest.RandomBenchmarkResult.plot_histogram" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots the distribution of a given statistic. The histogram
represents the distribution of the random strategies’ statistic
and the vertical line is the value of the benchmarked strategy’s
statistic.</p>
<p>This helps you determine if your strategy is statistically ‘better’
than the random versions.</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>statistic (str): Statistic - any numeric statistic in
Result is valid.</p></li>
<li><p>figsize ((x, y)): Figure size</p></li>
<li><p>title (str): Chart title</p></li>
<li><p>bins (int): Number of bins</p></li>
<li><p>kwargs (dict): Passed to pandas hist function.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="bt.backtest.RenormalizedFixedIncomeResult">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">bt.backtest.</span></span><span class="sig-name descname"><span class="pre">RenormalizedFixedIncomeResult</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">normalizing_value</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">backtests</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/backtest.html#RenormalizedFixedIncomeResult"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.backtest.RenormalizedFixedIncomeResult" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#bt.backtest.Result" title="bt.backtest.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">Result</span></code></a></p>
<p>A new result type to help compare results generated from
<a class="reference internal" href="#bt.core.FixedIncomeStrategy" title="bt.core.FixedIncomeStrategy"><code class="xref py py-class docutils literal notranslate"><span class="pre">FixedIncomeStrategy</span></code></a>.
Recall that in a fixed income strategy, the normalized prices are computed
using additive returns expressed as a percentage of current outstanding
notional (i.e. fixed-notional equivalent).
In strategies where the notional is varying, this may lead to counter-
intuitive results because the different terms in the sum are being scaled by
different notionals in the denominator (i.e. price could be below par, but
overall change in value is positive).</p>
<p>This class provides a way to “renormalize” the results with a different
denominator value or series, i.e. using max or average notional exposure,
or the risk exposure of the strategy.</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>normalizing_value: pd.Series, float or dict thereof(by strategy name)</p></li>
<li><p>backtests (list): List of backtests (i.e. from Result.backtest_list)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="bt.backtest.Result">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">bt.backtest.</span></span><span class="sig-name descname"><span class="pre">Result</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">backtests</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/backtest.html#Result"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.backtest.Result" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="http://pmorissette.github.io/ffn/ffn.html#ffn.core.GroupStats" title="(in ffn v0.3.6)"><code class="xref py py-class docutils literal notranslate"><span class="pre">GroupStats</span></code></a></p>
<p>Based on ffn’s GroupStats with a few extra helper methods.</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>backtests (list): List of backtests</p></li>
</ul>
</dd>
<dt>Attributes:</dt><dd><ul class="simple">
<li><p>backtest_list (list): List of bactests in the same order as provided</p></li>
<li><p>backtests (dict): Dict of backtests by name</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="bt.backtest.Result.display_monthly_returns">
<span class="sig-name descname"><span class="pre">display_monthly_returns</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">backtest</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/backtest.html#Result.display_monthly_returns"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.backtest.Result.display_monthly_returns" title="Permalink to this definition">¶</a></dt>
<dd><p>Display monthly returns for a specific backtest.</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><dl class="simple">
<dt>backtest (str, int): Backtest. Can be either a index (int) or the</dt><dd><p>name (str)</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="bt.backtest.Result.get_security_weights">
<span class="sig-name descname"><span class="pre">get_security_weights</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">backtest</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/backtest.html#Result.get_security_weights"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.backtest.Result.get_security_weights" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>backtest</strong> – (str, int) Backtest can be either a index (int) or the
name (str)</p></li>
<li><p><strong>filter</strong> – (list, str) filter columns for specific columns. Filter
is simply passed as is to DataFrame[filter], so use something
that makes sense with a DataFrame.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>(pd.DataFrame) DataFrame of security weights</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="bt.backtest.Result.get_transactions">
<span class="sig-name descname"><span class="pre">get_transactions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">strategy_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/backtest.html#Result.get_transactions"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.backtest.Result.get_transactions" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function that returns the transactions in the following format:</p>
<blockquote>
<div><p>Date, Security | quantity, price</p>
</div></blockquote>
<p>The result is a MultiIndex DataFrame.</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>strategy_name (str): If none, it will take the first backtest’s
strategy (self.backtest_list[0].name)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="bt.backtest.Result.get_weights">
<span class="sig-name descname"><span class="pre">get_weights</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">backtest</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/backtest.html#Result.get_weights"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.backtest.Result.get_weights" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>backtest</strong> – (str, int) Backtest can be either a index (int) or the
name (str)</p></li>
<li><p><strong>filter</strong> – (list, str) filter columns for specific columns. Filter
is simply passed as is to DataFrame[filter], so use something
that makes sense with a DataFrame.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>(pd.DataFrame) DataFrame of weights</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="bt.backtest.Result.plot_histogram">
<span class="sig-name descname"><span class="pre">plot_histogram</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">backtest</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwds</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/backtest.html#Result.plot_histogram"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.backtest.Result.plot_histogram" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots the return histogram of a given backtest over time.</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><dl class="simple">
<dt>backtest (str, int): Backtest. Can be either a index (int) or the</dt><dd><p>name (str)</p>
</dd>
</dl>
</li>
<li><p>kwds (dict): Keywords passed to plot_histogram</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="bt.backtest.Result.plot_security_weights">
<span class="sig-name descname"><span class="pre">plot_security_weights</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">backtest</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">figsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(15,</span> <span class="pre">5)</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwds</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/backtest.html#Result.plot_security_weights"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.backtest.Result.plot_security_weights" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots the security weights of a given backtest over time.</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><dl class="simple">
<dt>backtest (str, int): Backtest. Can be either a index (int) or the</dt><dd><p>name (str)</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>filter (list, str): filter columns for specific columns. Filter</dt><dd><p>is simply passed as is to DataFrame[filter], so use something
that makes sense with a DataFrame.</p>
</dd>
</dl>
</li>
<li><p>figsize ((width, height)): figure size</p></li>
<li><p>kwds (dict): Keywords passed to plot</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="bt.backtest.Result.plot_weights">
<span class="sig-name descname"><span class="pre">plot_weights</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">backtest</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">figsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(15,</span> <span class="pre">5)</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwds</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/backtest.html#Result.plot_weights"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.backtest.Result.plot_weights" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots the weights of a given backtest over time.</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>backtest (str, int): Backtest can be either a index (int) or the
name (str)</p></li>
<li><p>filter (list, str): filter columns for specific columns. Filter
is simply passed as is to DataFrame[filter], so use something
that makes sense with a DataFrame.</p></li>
<li><p>figsize ((width, height)): figure size</p></li>
<li><p>kwds (dict): Keywords passed to plot</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="bt.backtest.benchmark_random">
<span class="sig-prename descclassname"><span class="pre">bt.backtest.</span></span><span class="sig-name descname"><span class="pre">benchmark_random</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">backtest</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_strategy</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nsim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/backtest.html#benchmark_random"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.backtest.benchmark_random" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a backtest and a random strategy, compare backtest to
a number of random portfolios.</p>
<p>The idea here is to benchmark your strategy vs a bunch of
random strategies that have a similar structure but execute
some part of the logic randomly - basically you are trying to
determine if your strategy has any merit - does it beat
randomly picking weight? Or randomly picking the selected
securities?</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>backtest (Backtest): A backtest you want to benchmark</p></li>
<li><p>random_strategy (Strategy): A strategy you want to benchmark
against. The strategy should have a random component to
emulate skilless behavior.</p></li>
<li><p>nsim (int): number of random strategies to create.</p></li>
</ul>
</dd>
<dt>Returns:</dt><dd><p>RandomBenchmarkResult</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="bt.backtest.run">
<span class="sig-prename descclassname"><span class="pre">bt.backtest.</span></span><span class="sig-name descname"><span class="pre">run</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">backtests</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/backtest.html#run"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.backtest.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Runs a series of backtests and returns a Result
object containing the results of the backtests.</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>backtest (<a href="#id4"><span class="problematic" id="id5">*</span></a>list): List of backtests.</p></li>
</ul>
</dd>
<dt>Returns:</dt><dd><p>Result</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-bt.core">
<span id="core-module"></span><h2><code class="xref py py-mod docutils literal notranslate"><span class="pre">core</span></code> Module<a class="headerlink" href="#module-bt.core" title="Permalink to this heading">¶</a></h2>
<p>Contains the core building blocks of the framework.</p>
<dl class="py class">
<dt class="sig sig-object py" id="bt.core.Algo">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">bt.core.</span></span><span class="sig-name descname"><span class="pre">Algo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/core.html#Algo"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.core.Algo" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Algos are used to modularize strategy logic so that strategy logic becomes
modular, composable, more testable and less error prone. Basically, the
Algo should follow the unix philosophy - do one thing well.</p>
<p>In practice, algos are simply a function that receives one argument, the
Strategy (referred to as target) and are expected to return a bool.</p>
<p>When some state preservation is necessary between calls, the Algo
object can be used (this object). The __call___ method should be
implemented and logic defined therein to mimic a function call. A
simple function may also be used if no state preservation is necessary.</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>name (str): Algo name</p></li>
</ul>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="bt.core.Algo.name">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="#bt.core.Algo.name" title="Permalink to this definition">¶</a></dt>
<dd><p>Algo name.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="bt.core.AlgoStack">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">bt.core.</span></span><span class="sig-name descname"><span class="pre">AlgoStack</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">algos</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/core.html#AlgoStack"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.core.AlgoStack" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#bt.core.Algo" title="bt.core.Algo"><code class="xref py py-class docutils literal notranslate"><span class="pre">Algo</span></code></a></p>
<p>An AlgoStack derives from Algo runs multiple Algos until a
failure is encountered.</p>
<p>The purpose of an AlgoStack is to group a logic set of Algos together. Each
Algo in the stack is run. Execution stops if one Algo returns False.</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>algos (list): List of algos.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="bt.core.CouponPayingHedgeSecurity">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">bt.core.</span></span><span class="sig-name descname"><span class="pre">CouponPayingHedgeSecurity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">multiplier</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fixed_income</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lazy_add</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/core.html#CouponPayingHedgeSecurity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.core.CouponPayingHedgeSecurity" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#bt.core.CouponPayingSecurity" title="bt.core.CouponPayingSecurity"><code class="xref py py-class docutils literal notranslate"><span class="pre">CouponPayingSecurity</span></code></a></p>
<p>CouponPayingHedgeSecurity is a CouponPayingSecurity where the notional value is set to zero, and thus
does not count towards the notional value of the strategy. It is intended for use
in fixed income strategies.</p>
<p>For example in a corporate bond strategy, the notional value might refer to the size
of the corporate bond portfolio, and exclude the notional of treasury bonds or interest
rate swaps used as hedges.</p>
<dl class="py method">
<dt class="sig sig-object py" id="bt.core.CouponPayingHedgeSecurity.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">date</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inow</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/core.html#CouponPayingHedgeSecurity.update"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.core.CouponPayingHedgeSecurity.update" title="Permalink to this definition">¶</a></dt>
<dd><p>Update security with a given date and optionally, some data.
This will update price, value, weight, etc.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="bt.core.CouponPayingSecurity">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">bt.core.</span></span><span class="sig-name descname"><span class="pre">CouponPayingSecurity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">multiplier</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fixed_income</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lazy_add</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/core.html#CouponPayingSecurity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.core.CouponPayingSecurity" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#bt.core.FixedIncomeSecurity" title="bt.core.FixedIncomeSecurity"><code class="xref py py-class docutils literal notranslate"><span class="pre">FixedIncomeSecurity</span></code></a></p>
<p>CouponPayingSecurity expands on SecurityBase to handle securities which
pay (possibly irregular) coupons (or other forms of cash disbursement).
More generally, this can include instruments with any sort of carry,
including (potentially asymmetric) holding costs.</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>name (str): Security name</p></li>
<li><p>multiplier (float): security multiplier - typically used for
derivatives.</p></li>
<li><p>fixed_income (bool): Flag to control whether notional_value is based
only on quantity, or on market value (like an equity).
Defaults to notional weighting for coupon paying instruments.</p></li>
<li><p>lazy_add (bool): Flag to control whether instrument should be added
to strategy children lazily, i.e. only when there is a transaction
on the instrument. This improves performance of strategies which
transact on a sparse set of children.</p></li>
</ul>
</dd>
<dt>Attributes:</dt><dd><ul class="simple">
<li><p>SecurityBase attributes</p></li>
<li><p>coupon (float): Current coupon payment (quantity).</p></li>
<li><p>holding_cost (float): Current holding cost (quantity).</p></li>
</ul>
</dd>
</dl>
<p>Represents a coupon-paying security, where coupon payments adjust
the capital of the parent. Coupons and costs must be passed in during setup.</p>
<dl class="py property">
<dt class="sig sig-object py" id="bt.core.CouponPayingSecurity.coupon">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">coupon</span></span><a class="headerlink" href="#bt.core.CouponPayingSecurity.coupon" title="Permalink to this definition">¶</a></dt>
<dd><p>Current coupon payment (scaled by position)</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="bt.core.CouponPayingSecurity.coupons">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">coupons</span></span><a class="headerlink" href="#bt.core.CouponPayingSecurity.coupons" title="Permalink to this definition">¶</a></dt>
<dd><p>TimeSeries of coupons paid (scaled by position)</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="bt.core.CouponPayingSecurity.holding_cost">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">holding_cost</span></span><a class="headerlink" href="#bt.core.CouponPayingSecurity.holding_cost" title="Permalink to this definition">¶</a></dt>
<dd><p>Current holding cost (scaled by position)</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="bt.core.CouponPayingSecurity.holding_costs">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">holding_costs</span></span><a class="headerlink" href="#bt.core.CouponPayingSecurity.holding_costs" title="Permalink to this definition">¶</a></dt>
<dd><p>TimeSeries of coupons paid (scaled by position)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="bt.core.CouponPayingSecurity.setup">
<span class="sig-name descname"><span class="pre">setup</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">universe</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/core.html#CouponPayingSecurity.setup"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.core.CouponPayingSecurity.setup" title="Permalink to this definition">¶</a></dt>
<dd><p>Setup Security with universe and coupon data. Speeds up future runs.</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>universe (DataFrame): DataFrame of prices with security’s name as
one of the columns.</p></li>
<li><p>coupons (DataFrame): Manatory DataFrame of coupon/carry amount with
the same schema as universe.</p></li>
<li><p>cost_long (DataFrame): Optional DataFrame containing the cost of
holding a unit long position in the security (i.e. funding).</p></li>
<li><p>cost_short (DataFrame): Optional DataFrame containing the cost of
holding a unit short position in the security (i.e. repo).</p></li>
<li><p>kwargs (dict): Dictionary of additional information needed by
the strategy. In particular, often takes the form of a DataFrame
of security level information (i.e. signals, risk, etc).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="bt.core.CouponPayingSecurity.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">date</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inow</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/core.html#CouponPayingSecurity.update"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.core.CouponPayingSecurity.update" title="Permalink to this definition">¶</a></dt>
<dd><p>Update security with a given date and optionally, some data.
This will update price, value, weight, etc.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="bt.core.FixedIncomeSecurity">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">bt.core.</span></span><span class="sig-name descname"><span class="pre">FixedIncomeSecurity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">multiplier</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lazy_add</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/core.html#FixedIncomeSecurity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.core.FixedIncomeSecurity" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#bt.core.SecurityBase" title="bt.core.SecurityBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">SecurityBase</span></code></a></p>
<p>A Fixed Income Security is a security where notional value is
measured only based on the quantity (par value) of the security.
Only relevant when using <a class="reference internal" href="#bt.core.FixedIncomeStrategy" title="bt.core.FixedIncomeStrategy"><code class="xref py py-class docutils literal notranslate"><span class="pre">FixedIncomeStrategy</span></code></a>.</p>
<dl class="py method">
<dt class="sig sig-object py" id="bt.core.FixedIncomeSecurity.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">date</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inow</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/core.html#FixedIncomeSecurity.update"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.core.FixedIncomeSecurity.update" title="Permalink to this definition">¶</a></dt>
<dd><p>Update security with a given date and optionally, some data.
This will update price, value, weight, etc.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="bt.core.FixedIncomeStrategy">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">bt.core.</span></span><span class="sig-name descname"><span class="pre">FixedIncomeStrategy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algos</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">children</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/core.html#FixedIncomeStrategy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.core.FixedIncomeStrategy" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#bt.core.Strategy" title="bt.core.Strategy"><code class="xref py py-class docutils literal notranslate"><span class="pre">Strategy</span></code></a></p>
<p>FixedIncomeStrategy is an alias for Strategy where the fixed_income flag
is set to True.</p>
<dl class="simple">
<dt>For this type of strategy:</dt><dd><ul class="simple">
<li><p>capital allocations are not necessary, and initial capital is not used</p></li>
<li><p>bankruptcy is disabled (and should be modeled explicitly via an Algo)</p></li>
<li><p>weights are based off notional_value rather than value</p></li>
<li><p>strategy price is computed from additive PNL returns
per unit of current notional_value, with a reference price of PAR.
<a class="reference internal" href="#bt.backtest.RenormalizedFixedIncomeResult" title="bt.backtest.RenormalizedFixedIncomeResult"><code class="xref py py-class docutils literal notranslate"><span class="pre">RenormalizedFixedIncomeResult</span></code></a>
can be used to re-calculate the price-based performance statistics
using different normalization schemes on total pnl.</p></li>
<li><p>“transact” assumes the role of “allocate”, in order to buy/sell
children on a weighted notional basis</p></li>
<li><p>“rebalance” adjusts notionals rather than capital allocations based
on weights</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="bt.core.HedgeSecurity">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">bt.core.</span></span><span class="sig-name descname"><span class="pre">HedgeSecurity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">multiplier</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lazy_add</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/core.html#HedgeSecurity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.core.HedgeSecurity" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#bt.core.SecurityBase" title="bt.core.SecurityBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">SecurityBase</span></code></a></p>
<p>HedgeSecurity is a SecurityBase where the notional value is set to zero, and thus
does not count towards the notional value of the strategy. It is intended for use
in fixed income strategies.</p>
<p>For example in a corporate bond strategy, the notional value might refer to the size
of the corporate bond portfolio, and exclude the notional of treasury bonds or interest
rate swaps used as hedges.</p>
<dl class="py method">
<dt class="sig sig-object py" id="bt.core.HedgeSecurity.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">date</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inow</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/core.html#HedgeSecurity.update"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.core.HedgeSecurity.update" title="Permalink to this definition">¶</a></dt>
<dd><p>Update security with a given date and optionally, some data.
This will update price, value, weight, etc.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="bt.core.Node">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">bt.core.</span></span><span class="sig-name descname"><span class="pre">Node</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parent</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">children</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/core.html#Node"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.core.Node" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>The Node is the main building block in bt’s tree structure design.
Both StrategyBase and SecurityBase inherit Node. It contains the
core functionality of a tree node.</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>name (str): The Node name</p></li>
<li><p>parent (Node): The parent Node</p></li>
<li><p>children (dict, list): A collection of children. If dict,
the format is {name: child}, if list then list of children.
Children can be any type of Node or str.
String values correspond to children which will be lazily created
with that name when needed.</p></li>
</ul>
</dd>
<dt>Attributes:</dt><dd><ul class="simple">
<li><p>name (str): Node name</p></li>
<li><p>parent (Node): Node parent</p></li>
<li><p>root (Node): Root node of the tree (topmost node)</p></li>
<li><p>children (dict): Node’s children</p></li>
<li><p>now (datetime): Used when backtesting to store current date</p></li>
<li><p>stale (bool): Flag used to determine if Node is stale and need
updating</p></li>
<li><p>prices (TimeSeries): Prices of the Node. Prices for a security will
be the security’s price, for a strategy it will be an index that
reflects the value of the strategy over time.</p></li>
<li><p>price (float): last price</p></li>
<li><p>value (float): last value</p></li>
<li><p>notional_value (float): last notional value. Notional value is used
when fixed_income=True. It is always positive for strategies, but
is signed for securities (and typically set to either market value,
position, or zero).</p></li>
<li><p>weight (float): weight in parent</p></li>
<li><p>full_name (str): Name including parents’ names</p></li>
<li><p>members (list): Current Node + node’s children</p></li>
<li><p>fixed_income (bool): Whether the node corresponds to a fixed income
component, which would use notional-weighting instead of market
value weighing. See also <a class="reference internal" href="#bt.core.FixedIncomeStrategy" title="bt.core.FixedIncomeStrategy"><code class="xref py py-class docutils literal notranslate"><span class="pre">FixedIncomeStrategy</span></code></a>
for more details.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="bt.core.Node.adjust">
<span class="sig-name descname"><span class="pre">adjust</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">amount</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">update</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flow</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/core.html#Node.adjust"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.core.Node.adjust" title="Permalink to this definition">¶</a></dt>
<dd><p>Adjust Node value by amount.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="bt.core.Node.allocate">
<span class="sig-name descname"><span class="pre">allocate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">amount</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">update</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/core.html#Node.allocate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.core.Node.allocate" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocate capital to Node.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="bt.core.Node.fixed_income">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">fixed_income</span></span><a class="headerlink" href="#bt.core.Node.fixed_income" title="Permalink to this definition">¶</a></dt>
<dd><p>Whether the node is a fixed income node (using notional weighting).</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="bt.core.Node.full_name">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">full_name</span></span><a class="headerlink" href="#bt.core.Node.full_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="bt.core.Node.members">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">members</span></span><a class="headerlink" href="#bt.core.Node.members" title="Permalink to this definition">¶</a></dt>
<dd><p>Node members. Members include current node as well as Node’s
children.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="bt.core.Node.notional_value">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">notional_value</span></span><a class="headerlink" href="#bt.core.Node.notional_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Current notional value of the Node</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="bt.core.Node.price">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">price</span></span><a class="headerlink" href="#bt.core.Node.price" title="Permalink to this definition">¶</a></dt>
<dd><p>Current price of the Node</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="bt.core.Node.prices">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">prices</span></span><a class="headerlink" href="#bt.core.Node.prices" title="Permalink to this definition">¶</a></dt>
<dd><p>A TimeSeries of the Node’s price.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="bt.core.Node.setup">
<span class="sig-name descname"><span class="pre">setup</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">universe</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/core.html#Node.setup"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.core.Node.setup" title="Permalink to this definition">¶</a></dt>
<dd><p>Setup method used to initialize a Node with a universe, and potentially other information.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="bt.core.Node.to_dot">
<span class="sig-name descname"><span class="pre">to_dot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">root</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/core.html#Node.to_dot"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.core.Node.to_dot" title="Permalink to this definition">¶</a></dt>
<dd><p>Represent the node structure in DOT format.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="bt.core.Node.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">date</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inow</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/core.html#Node.update"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.core.Node.update" title="Permalink to this definition">¶</a></dt>
<dd><p>Update Node with latest date, and optionally some data.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="bt.core.Node.use_integer_positions">
<span class="sig-name descname"><span class="pre">use_integer_positions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">integer_positions</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/core.html#Node.use_integer_positions"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.core.Node.use_integer_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Set indicator to use (or not) integer positions for a given strategy or
security.</p>
<p>By default all positions in number of stocks should be integer.
However this may lead to unexpected results when working with adjusted
prices of stocks. Because of series of reverse splits of stocks, the
adjusted prices back in time might be high. Thus rounding of desired
amount of stocks to buy may lead to having 0, and thus ignoring this
stock from backtesting.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="bt.core.Node.value">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">value</span></span><a class="headerlink" href="#bt.core.Node.value" title="Permalink to this definition">¶</a></dt>
<dd><p>Current value of the Node</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="bt.core.Node.weight">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">weight</span></span><a class="headerlink" href="#bt.core.Node.weight" title="Permalink to this definition">¶</a></dt>
<dd><p>Current weight of the Node (with respect to the parent).</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="bt.core.Security">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">bt.core.</span></span><span class="sig-name descname"><span class="pre">Security</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">multiplier</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lazy_add</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/core.html#Security"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.core.Security" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#bt.core.SecurityBase" title="bt.core.SecurityBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">SecurityBase</span></code></a></p>
<p>A standard security with no special features, and where notional value
is measured based on market value (notional times price).
It exists to be able to identify standard securities from nonstandard
ones via isinstance, i.e. isinstance( sec, Security ) would only return
True for a vanilla security, whereas SecurityBase would return True for
all securities.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="bt.core.SecurityBase">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">bt.core.</span></span><span class="sig-name descname"><span class="pre">SecurityBase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">multiplier</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lazy_add</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/core.html#SecurityBase"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.core.SecurityBase" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#bt.core.Node" title="bt.core.Node"><code class="xref py py-class docutils literal notranslate"><span class="pre">Node</span></code></a></p>
<p>Security Node. Used to define a security within a tree.
A Security’s has no children. It simply models an asset that can be bought
or sold.</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>name (str): Security name</p></li>
<li><p>multiplier (float): security multiplier - typically used for
derivatives or to trade in lots. The quantity of the Security will
always be multiplied by this to determine the underlying amount.</p></li>
<li><p>lazy_add (bool): Flag to control whether instrument should be added
to strategy children lazily, i.e. only when there is a transaction
on the instrument. This improves performance of strategies which
transact on a sparse set of children.</p></li>
</ul>
</dd>
<dt>Attributes:</dt><dd><ul class="simple">
<li><p>name (str): Security name</p></li>
<li><p>parent (Security): Security parent</p></li>
<li><p>root (Security): Root node of the tree (topmost node)</p></li>
<li><p>now (datetime): Used when backtesting to store current date</p></li>
<li><p>stale (bool): Flag used to determine if Security is stale and need
updating</p></li>
<li><p>prices (TimeSeries): Security prices.</p></li>
<li><p>price (float): last price</p></li>
<li><p>outlays (TimeSeries): Series of outlays. Positive outlays mean
capital was allocated to security and security consumed that
amount.  Negative outlays are the opposite. This can be useful for
calculating turnover at the strategy level.</p></li>
<li><p>value (float): last value - basically position * price * multiplier</p></li>
<li><p>weight (float): weight in parent</p></li>
<li><p>full_name (str): Name including parents’ names</p></li>
<li><p>members (list): Current Security + strategy’s children</p></li>
<li><p>position (float): Current position (quantity).</p></li>
<li><p>bidoffer (float): Current bid/offer spread</p></li>
<li><p>bidoffers (TimeSeries): Series of bid/offer spreads</p></li>
<li><p>bidoffer_paid (TimeSeries): Series of bid/offer paid on transactions</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="bt.core.SecurityBase.allocate">
<span class="sig-name descname"><span class="pre">allocate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">amount</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">update</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/core.html#SecurityBase.allocate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.core.SecurityBase.allocate" title="Permalink to this definition">¶</a></dt>
<dd><p>This allocates capital to the Security. This is the method used to
buy/sell the security.</p>
<p>A given amount of shares will be determined on the current price, a
commission will be calculated based on the parent’s commission fn, and
any remaining capital will be passed back up  to parent as an
adjustment.</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>amount (float): Amount of adjustment.</p></li>
<li><p>update (bool): Force update?</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="bt.core.SecurityBase.bidoffer">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">bidoffer</span></span><a class="headerlink" href="#bt.core.SecurityBase.bidoffer" title="Permalink to this definition">¶</a></dt>
<dd><p>Current bid/offer spread.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="bt.core.SecurityBase.bidoffer_paid">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">bidoffer_paid</span></span><a class="headerlink" href="#bt.core.SecurityBase.bidoffer_paid" title="Permalink to this definition">¶</a></dt>
<dd><p>TimeSeries of bid/offer spread paid on transactions in the current step</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="bt.core.SecurityBase.bidoffers">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">bidoffers</span></span><a class="headerlink" href="#bt.core.SecurityBase.bidoffers" title="Permalink to this definition">¶</a></dt>
<dd><p>TimeSeries of bid/offer spread</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="bt.core.SecurityBase.bidoffers_paid">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">bidoffers_paid</span></span><a class="headerlink" href="#bt.core.SecurityBase.bidoffers_paid" title="Permalink to this definition">¶</a></dt>
<dd><p>TimeSeries of bid/offer spread paid on transactions in the current step</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="bt.core.SecurityBase.commission">
<span class="sig-name descname"><span class="pre">commission</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/core.html#SecurityBase.commission"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.core.SecurityBase.commission" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the commission (transaction fee) based on quantity and
price.  Uses the parent’s commission_fn.</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>q (float): quantity</p></li>
<li><p>p (float): price</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="bt.core.SecurityBase.multiplier">
<span class="sig-name descname"><span class="pre">multiplier</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">0.0</span></em><a class="headerlink" href="#bt.core.SecurityBase.multiplier" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="bt.core.SecurityBase.notional_values">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">notional_values</span></span><a class="headerlink" href="#bt.core.SecurityBase.notional_values" title="Permalink to this definition">¶</a></dt>
<dd><p>TimeSeries of notional values.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="bt.core.SecurityBase.outlay">
<span class="sig-name descname"><span class="pre">outlay</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/core.html#SecurityBase.outlay"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.core.SecurityBase.outlay" title="Permalink to this definition">¶</a></dt>
<dd><p>Determines the complete cash outlay (including commission) necessary
given a quantity q.
Second returning parameter is a commission itself.</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>q (float): quantity</p></li>
<li><p>p (float): price override</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="bt.core.SecurityBase.outlays">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">outlays</span></span><a class="headerlink" href="#bt.core.SecurityBase.outlays" title="Permalink to this definition">¶</a></dt>
<dd><p>TimeSeries of outlays. Positive outlays (buys) mean this security
received and consumed capital (capital was allocated to it). Negative
outlays are the opposite (the security close/sold, and returned capital
to parent).</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="bt.core.SecurityBase.position">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">position</span></span><a class="headerlink" href="#bt.core.SecurityBase.position" title="Permalink to this definition">¶</a></dt>
<dd><p>Current position</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="bt.core.SecurityBase.positions">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">positions</span></span><a class="headerlink" href="#bt.core.SecurityBase.positions" title="Permalink to this definition">¶</a></dt>
<dd><p>TimeSeries of positions.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="bt.core.SecurityBase.price">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">price</span></span><a class="headerlink" href="#bt.core.SecurityBase.price" title="Permalink to this definition">¶</a></dt>
<dd><p>Current price.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="bt.core.SecurityBase.prices">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">prices</span></span><a class="headerlink" href="#bt.core.SecurityBase.prices" title="Permalink to this definition">¶</a></dt>
<dd><p>TimeSeries of prices.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="bt.core.SecurityBase.run">
<span class="sig-name descname"><span class="pre">run</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/core.html#SecurityBase.run"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.core.SecurityBase.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Does nothing - securities have nothing to do on run.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="bt.core.SecurityBase.setup">
<span class="sig-name descname"><span class="pre">setup</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">universe</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/core.html#SecurityBase.setup"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.core.SecurityBase.setup" title="Permalink to this definition">¶</a></dt>
<dd><p>Setup Security with universe. Speeds up future runs.</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>universe (DataFrame): DataFrame of prices with security’s name as
one of the columns.</p></li>
<li><p>bidoffer (DataFrame): Optional argument that represents the
bid/offer spread on each security across time. If provided, the
strategy will account for these costs when rebalancing.</p></li>
<li><p>kwargs (dict): Dictionary of additional information needed by
the strategy. In particular, often takes the form of a DataFrame
of security level information (i.e. signals, risk, etc).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="bt.core.SecurityBase.transact">
<span class="sig-name descname"><span class="pre">transact</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">update</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">update_self</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">price</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/core.html#SecurityBase.transact"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.core.SecurityBase.transact" title="Permalink to this definition">¶</a></dt>
<dd><p>This transacts the Security. This is the method used to
buy/sell the security for a given quantity.</p>
<p>The amount of shares is explicitly provided, a
commission will be calculated based on the parent’s commission fn, and
any remaining capital will be passed back up  to parent as an
adjustment.</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>amount (float): Amount of adjustment.</p></li>
<li><p>update (bool): Force update on parent due to transaction proceeds</p></li>
<li><p>update_self (bool): Check for update on self</p></li>
<li><p>price (float): Optional price if the transaction happens at a bespoke level</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="bt.core.SecurityBase.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">date</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inow</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/core.html#SecurityBase.update"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.core.SecurityBase.update" title="Permalink to this definition">¶</a></dt>
<dd><p>Update security with a given date and optionally, some data.
This will update price, value, weight, etc.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="bt.core.SecurityBase.values">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">values</span></span><a class="headerlink" href="#bt.core.SecurityBase.values" title="Permalink to this definition">¶</a></dt>
<dd><p>TimeSeries of values.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="bt.core.Strategy">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">bt.core.</span></span><span class="sig-name descname"><span class="pre">Strategy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algos</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">children</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parent</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/core.html#Strategy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.core.Strategy" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#bt.core.StrategyBase" title="bt.core.StrategyBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">StrategyBase</span></code></a></p>
<p>Strategy expands on the StrategyBase and incorporates Algos.</p>
<p>Basically, a Strategy is built by passing in a set of algos. These algos
will be placed in an Algo stack and the run function will call the stack.</p>
<p>Furthermore, two class attributes are created to pass data between algos.
perm for permanent data, temp for temporary data.</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>name (str): Strategy name</p></li>
<li><p>algos (list): List of Algos to be passed into an AlgoStack</p></li>
<li><p>children (dict, list): Children - useful when you want to create
strategies of strategies
Children can be any type of Node or str.
String values correspond to children which will be lazily created
with that name when needed.</p></li>
<li><p>parent (Node): The parent Node</p></li>
</ul>
</dd>
<dt>Attributes:</dt><dd><ul class="simple">
<li><p>stack (AlgoStack): The stack</p></li>
<li><p>temp (dict): A dict containing temporary data - cleared on each call
to run. This can be used to pass info to other algos.</p></li>
<li><p>perm (dict): Permanent data used to pass info from one algo to
another. Not cleared on each pass.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="bt.core.Strategy.run">
<span class="sig-name descname"><span class="pre">run</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/core.html#Strategy.run"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.core.Strategy.run" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the main logic method. Override this method to provide some
algorithm to execute on each date change. This method is called by
backtester.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="bt.core.StrategyBase">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">bt.core.</span></span><span class="sig-name descname"><span class="pre">StrategyBase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">children</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parent</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/core.html#StrategyBase"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.core.StrategyBase" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#bt.core.Node" title="bt.core.Node"><code class="xref py py-class docutils literal notranslate"><span class="pre">Node</span></code></a></p>
<p>Strategy Node. Used to define strategy logic within a tree.
A Strategy’s role is to allocate capital to it’s children
based on a function.</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>name (str): Strategy name</p></li>
<li><p>children (dict, list): A collection of children. If dict,
the format is {name: child}, if list then list of children.
Children can be any type of Node or str.
String values correspond to children which will be lazily created
with that name when needed.</p></li>
<li><p>parent (Node): The parent Node</p></li>
</ul>
</dd>
<dt>Attributes:</dt><dd><ul class="simple">
<li><p>name (str): Strategy name</p></li>
<li><p>parent (Strategy): Strategy parent</p></li>
<li><p>root (Strategy): Root node of the tree (topmost node)</p></li>
<li><p>children (dict): Strategy’s children</p></li>
<li><p>now (datetime): Used when backtesting to store current date</p></li>
<li><p>stale (bool): Flag used to determine if Strategy is stale and need
updating</p></li>
<li><p>prices (TimeSeries): Prices of the Strategy - basically an index that
reflects the value of the strategy over time.</p></li>
<li><p>outlays (DataFrame): Outlays for each SecurityBase child</p></li>
<li><p>price (float): last price</p></li>
<li><p>value (float): last value</p></li>
<li><p>notional_value (float): last notional value</p></li>
<li><p>weight (float): weight in parent</p></li>
<li><p>full_name (str): Name including parents’ names</p></li>
<li><p>members (list): Current Strategy + strategy’s children</p></li>
<li><p>securities (list): List of strategy children that are of type
SecurityBase</p></li>
<li><p>commission_fn (fn(quantity, price)): A function used to determine the
commission (transaction fee) amount. Could be used to model
slippage (implementation shortfall). Note that often fees are
symmetric for buy and sell and absolute value of quantity should
be used for calculation.</p></li>
<li><p>capital (float): Capital amount in Strategy - cash</p></li>
<li><p>universe (DataFrame): Data universe available at the current time.
Universe contains the data passed in when creating a Backtest. Use
this data to determine strategy logic.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="bt.core.StrategyBase.adjust">
<span class="sig-name descname"><span class="pre">adjust</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">amount</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">update</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flow</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fee</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/core.html#StrategyBase.adjust"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.core.StrategyBase.adjust" title="Permalink to this definition">¶</a></dt>
<dd><p>Adjust capital - used to inject capital to a Strategy. This injection
of capital will have no effect on the children.</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>amount (float): Amount to adjust by.</p></li>
<li><p>update (bool): Force update?</p></li>
<li><p>flow (bool): Is this adjustment a flow? A flow will not have an
impact on the performance (price index). Example of flows are
simply capital injections (say a monthly contribution to a
portfolio). This should not be reflected in the returns. A
non-flow (flow=False) does impact performance. A good example
of this is a commission, or a dividend.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="bt.core.StrategyBase.allocate">
<span class="sig-name descname"><span class="pre">allocate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">amount</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">child</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">update</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/core.html#StrategyBase.allocate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.core.StrategyBase.allocate" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocate capital to Strategy. By default, capital is allocated
recursively down the children, proportionally to the children’s
weights.  If a child is specified, capital will be allocated
to that specific child.</p>
<p>Allocation also have a side-effect. They will deduct the same amount
from the parent’s “account” to offset the allocation. If there is
remaining capital after allocation, it will remain in Strategy.</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>amount (float): Amount to allocate.</p></li>
<li><p>child (str): If specified, allocation will be directed to child
only. Specified by name.</p></li>
<li><p>update (bool): Force update.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="bt.core.StrategyBase.bankrupt">
<span class="sig-name descname"><span class="pre">bankrupt</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">False</span></em><a class="headerlink" href="#bt.core.StrategyBase.bankrupt" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="bt.core.StrategyBase.bidoffer_paid">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">bidoffer_paid</span></span><a class="headerlink" href="#bt.core.StrategyBase.bidoffer_paid" title="Permalink to this definition">¶</a></dt>
<dd><p>Bid/offer spread paid on transactions in the current step</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="bt.core.StrategyBase.bidoffers_paid">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">bidoffers_paid</span></span><a class="headerlink" href="#bt.core.StrategyBase.bidoffers_paid" title="Permalink to this definition">¶</a></dt>
<dd><p>TimeSeries of bid/offer spread paid on transactions in each step</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="bt.core.StrategyBase.capital">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">capital</span></span><a class="headerlink" href="#bt.core.StrategyBase.capital" title="Permalink to this definition">¶</a></dt>
<dd><p>Current capital - amount of unallocated capital left in strategy.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="bt.core.StrategyBase.cash">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">cash</span></span><a class="headerlink" href="#bt.core.StrategyBase.cash" title="Permalink to this definition">¶</a></dt>
<dd><p>TimeSeries of unallocated capital.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="bt.core.StrategyBase.close">
<span class="sig-name descname"><span class="pre">close</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">child</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">update</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/core.html#StrategyBase.close"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.core.StrategyBase.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Close a child position - alias for rebalance(0, child). This will also
flatten (close out all) the child’s children.</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>child (str): Child, specified by name.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="bt.core.StrategyBase.fees">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">fees</span></span><a class="headerlink" href="#bt.core.StrategyBase.fees" title="Permalink to this definition">¶</a></dt>
<dd><p>TimeSeries of fees.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="bt.core.StrategyBase.flatten">
<span class="sig-name descname"><span class="pre">flatten</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/core.html#StrategyBase.flatten"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.core.StrategyBase.flatten" title="Permalink to this definition">¶</a></dt>
<dd><p>Close all child positions.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="bt.core.StrategyBase.flows">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">flows</span></span><a class="headerlink" href="#bt.core.StrategyBase.flows" title="Permalink to this definition">¶</a></dt>
<dd><p>TimeSeries of flows.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="bt.core.StrategyBase.get_data">
<span class="sig-name descname"><span class="pre">get_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">key</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/core.html#StrategyBase.get_data"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.core.StrategyBase.get_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns additional data that was passed to the setup function via kwargs,
for use in the algos. This allows algos to reference data sources “by name”,
where the binding of the data to the name happens at Backtest creation
time rather than at Strategy definition time, allowing the same strategies
to be run against different data sets more easily.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="bt.core.StrategyBase.get_transactions">
<span class="sig-name descname"><span class="pre">get_transactions</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/core.html#StrategyBase.get_transactions"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.core.StrategyBase.get_transactions" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function that returns the transactions in the following format:</p>
<blockquote>
<div><p>Date, Security | quantity, price</p>
</div></blockquote>
<p>The result is a MultiIndex DataFrame.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="bt.core.StrategyBase.notional_values">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">notional_values</span></span><a class="headerlink" href="#bt.core.StrategyBase.notional_values" title="Permalink to this definition">¶</a></dt>
<dd><p>TimeSeries of notional values.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="bt.core.StrategyBase.outlays">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">outlays</span></span><a class="headerlink" href="#bt.core.StrategyBase.outlays" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a DataFrame of outlays for each child SecurityBase</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="bt.core.StrategyBase.positions">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">positions</span></span><a class="headerlink" href="#bt.core.StrategyBase.positions" title="Permalink to this definition">¶</a></dt>
<dd><p>TimeSeries of positions.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="bt.core.StrategyBase.price">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">price</span></span><a class="headerlink" href="#bt.core.StrategyBase.price" title="Permalink to this definition">¶</a></dt>
<dd><p>Current price.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="bt.core.StrategyBase.prices">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">prices</span></span><a class="headerlink" href="#bt.core.StrategyBase.prices" title="Permalink to this definition">¶</a></dt>
<dd><p>TimeSeries of prices.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="bt.core.StrategyBase.rebalance">
<span class="sig-name descname"><span class="pre">rebalance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">weight</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">child</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">nan</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">update</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/core.html#StrategyBase.rebalance"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.core.StrategyBase.rebalance" title="Permalink to this definition">¶</a></dt>
<dd><p>Rebalance a child to a given weight.</p>
<p>This is a helper method to simplify code logic. This method is used
when we want to see the weight of a particular child to a set amount.
It is similar to allocate, but it calculates the appropriate allocation
based on the current weight. For fixed income strategies, it uses
transact to rebalance based on notional value instead of capital.</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>weight (float): The target weight. Usually between -1.0 and 1.0.</p></li>
<li><p>child (str): child to allocate to - specified by name.</p></li>
<li><p>base (float): If specified, this is the base amount all weight
delta calculations will be based off of. This is useful when we
determine a set of weights and want to rebalance each child
given these new weights. However, as we iterate through each
child and call this method, the base (which is by default the
current value) will change. Therefore, we can set this base to
the original value before the iteration to ensure the proper
allocations are made.</p></li>
<li><p>update (bool): Force update?</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="bt.core.StrategyBase.run">
<span class="sig-name descname"><span class="pre">run</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/core.html#StrategyBase.run"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.core.StrategyBase.run" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the main logic method. Override this method to provide some
algorithm to execute on each date change. This method is called by
backtester.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="bt.core.StrategyBase.securities">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">securities</span></span><a class="headerlink" href="#bt.core.StrategyBase.securities" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of children that are of type SecurityBase</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="bt.core.StrategyBase.set_commissions">
<span class="sig-name descname"><span class="pre">set_commissions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fn</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/core.html#StrategyBase.set_commissions"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.core.StrategyBase.set_commissions" title="Permalink to this definition">¶</a></dt>
<dd><p>Set commission (transaction fee) function.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>fn (fn(quantity, price)): Function used to determine commission
amount.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="bt.core.StrategyBase.setup">
<span class="sig-name descname"><span class="pre">setup</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">universe</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/core.html#StrategyBase.setup"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.core.StrategyBase.setup" title="Permalink to this definition">¶</a></dt>
<dd><p>Setup strategy with universe. This will speed up future calculations
and updates.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="bt.core.StrategyBase.setup_from_parent">
<span class="sig-name descname"><span class="pre">setup_from_parent</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/core.html#StrategyBase.setup_from_parent"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.core.StrategyBase.setup_from_parent" title="Permalink to this definition">¶</a></dt>
<dd><p>Setup a strategy from the parent. Used when dynamically creating
child strategies.</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><dl class="simple">
<dt>kwargs: additional arguments that will be passed to setup</dt><dd><p>(potentially overriding those from the parent)</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="bt.core.StrategyBase.transact">
<span class="sig-name descname"><span class="pre">transact</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">child</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">update</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/core.html#StrategyBase.transact"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.core.StrategyBase.transact" title="Permalink to this definition">¶</a></dt>
<dd><p>Transact a notional amount q in the Strategy. By default, it is allocated
recursively down the children, proportionally to the children’s
weights. Recursive allocation only works for fixed income strategies.
If a child is specified, notional will be allocated
to that specific child.</p>
<dl class="simple">
<dt>Args:</dt><dd><ul class="simple">
<li><p>q (float): Notional quantity to allocate.</p></li>
<li><p>child (str): If specified, allocation will be directed to child
only. Specified by name.</p></li>
<li><p>update (bool): Force update.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="bt.core.StrategyBase.universe">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">universe</span></span><a class="headerlink" href="#bt.core.StrategyBase.universe" title="Permalink to this definition">¶</a></dt>
<dd><p>Data universe available at the current time.
Universe contains the data passed in when creating a Backtest.
Use this data to determine strategy logic.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="bt.core.StrategyBase.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">date</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inow</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/core.html#StrategyBase.update"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.core.StrategyBase.update" title="Permalink to this definition">¶</a></dt>
<dd><p>Update strategy. Updates prices, values, weight, etc.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="bt.core.StrategyBase.values">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">values</span></span><a class="headerlink" href="#bt.core.StrategyBase.values" title="Permalink to this definition">¶</a></dt>
<dd><p>TimeSeries of values.</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="bt.core.is_zero">
<span class="sig-prename descclassname"><span class="pre">bt.core.</span></span><span class="sig-name descname"><span class="pre">is_zero</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/bt/core.html#is_zero"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#bt.core.is_zero" title="Permalink to this definition">¶</a></dt>
<dd><p>Test for zero that is robust against floating point precision errors</p>
</dd></dl>

</div>
</div>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
        <aside>

            
            <a href="index.html" id="logo" title=bt><img class="logo" src="_static/logo.png" width="150px" height="150px" title=bt /></a>
            
            
            <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="index.html"> Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="install.html"> Installation Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="algos.html"> All About Algos</a></li>
<li class="toctree-l1"><a class="reference internal" href="tree.html"> The Tree Structure</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples.html"> Examples</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#"> API</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id1"><code class="xref py py-mod docutils literal notranslate"><span class="pre">bt</span></code> Package</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-bt.algos"><code class="xref py py-mod docutils literal notranslate"><span class="pre">algos</span></code> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-bt.backtest"><code class="xref py py-mod docutils literal notranslate"><span class="pre">backtest</span></code> Module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-bt.core"><code class="xref py py-mod docutils literal notranslate"><span class="pre">core</span></code> Module</a></li>
</ul>
</li>
</ul>


            
            <ul>
                <li><a href="https://github.com/pmorissette/bt">Github</a></li>
            </ul>
            
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </aside>
    
      <div class="clearer"></div>
    </div>
        <div class="footer">
            bt was created by Philippe Morissette.
If you find a bug, please <a href="https://github.com/pmorissette/bt/issues/new" title="Open a new issue on Github">submit an issue</a> on Github.

        </div>

        
        <script>
            (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
            })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

            ga('create', 'UA-52308448-3', 'auto');
            ga('require', 'displayfeatures');
            ga('send', 'pageview');
        </script>
        
  </body>
</html>